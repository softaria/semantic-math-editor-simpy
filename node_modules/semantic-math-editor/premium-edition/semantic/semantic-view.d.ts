/**
 * @hidden
 * @packageDocumentation
 */
import { AbstractCellNode, AnyNode, AnyNodeVisitor, NonTerminal, NonTerminalVisitor, NothingNode, PrivateTerminal, RawNode, RootNode, Terminal, TerminalVisitor } from "../../standard-edition/model/model-base";
import { AbsNode, AbstractBracketsNode, AndNode, ApproxEqualsNode, BinaryOperationNode, BinaryOperationNodeVisitor, BracketsNodeVisitor, ClosedIntervalNode, CommaNode, ConstantNode, Constants, DeterminantNode, DivideNode, EmptysetVariableNode, EqualityType, EqualsNode, FuncNode, GreaterOrEqualsNode, GreaterThanNode, GreekVariableNode, IncludeSetNode, IntegralNode, IntersectionSetNode, LatinVariableNode, LeftClosedIntervalNode, LessOrEqualsNode, LessThanNode, LimNode, LogNode, MathRootNode, MinMaxNode, MinusNode, MultiplyNode, NotEqualsNode, NumSetLetters, NumsetVariableNode, OpenBracketsNode, OperatorNameNode, OrNode, PiecewiseFunctionNode, PlusNode, PredicateNode, PrimeNode, ProdOrSumNode, RightClosedIntervalNode, SetNode, SubIndexNode, SupIndexNode, SupSubIndexNode, SystemOfEquationsNode, TrigName, UnaryMinusNode, UndefinedNode, UnionSetNode, ValueNode, VerticalBarNode } from "../../standard-edition/model/model-math";
import { VisualGraph } from "../../standard-edition/structure/visual-levels";
import { SemanticContext } from "../../standard-edition/engine/semantic-context";
import { SemanticError } from "../../standard-edition/model/errors";
export interface SemanticNode<T> {
    accept(): T;
}
export declare class ArgumentList<T> {
    readonly arguments: SemanticNode<T>[];
    readonly commaIds: number[];
    constructor(args: SemanticNode<T>[], commaIds: number[]);
    static empty<T>(): ArgumentList<T>;
}
export declare enum ErrorType {
    unexpectedPlaceholder = "unexpectedPlaceholder",
    unexpectedComma = "unexpectedComma",
    upLimitIntegral = "upLimitIntegral",
    grammarError = "grammarError",
    badValueFormat = "badValueFormat",
    badInterval = "badInterval",
    badPredicate = "badPredicate",
    equalityMismatch = "equalityMismatch",
    missingParentheses = "missingParentheses"
}
export declare enum LimitType {
    unspecified = "unspecified",
    left = "left",
    right = "right"
}
export declare enum LeibnizDerivativeType {
    basic = "basic",
    withParentheses = "withParentheses"
}
export interface SemanticVisitor<T> {
    visitAbs(child: SemanticNode<T>, symbols: {
        par: number;
    }, errors: SemanticError[]): T;
    visitAnd(left: SemanticNode<T>, right: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitAreaIntegral(integrand: SemanticNode<T>, differential: SemanticNode<T>, area: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitBrackets(type: IntervalType, expression: SemanticNode<T>, symbols: {
        symbol: number;
    }, errors: SemanticError[]): T;
    visitComma(left: SemanticNode<T>, right: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitConstant(value: Constants, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitDefiniteIntegral(integrand: SemanticNode<T>, differential: SemanticNode<T>, downLimit: SemanticNode<T>, upLimit: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitDerivative(degree: number, child: SemanticNode<T>, symbols: {
        rightBoundary: number;
        parentheses: number;
        values: number[];
    }, errors: SemanticError[]): T;
    visitDeterminant(elements: SemanticNode<T>[][], symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitDifferential(child: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitDivide(numerator: SemanticNode<T>, denominator: SemanticNode<T>, symbols: {
        fraction: number;
    }, errors: SemanticError[]): T;
    visitEmptySet(symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitEqIneq(type: EqualityType, left: SemanticNode<T>, right: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitExpressionSet(set: ArgumentList<T>, symbols: {
        braces: number;
    }, errors: SemanticError[]): T;
    visitFunctionDifference(func: SemanticNode<T>, upLimit: SemanticNode<T>, downLimit: SemanticNode<T>, symbols: {
        op: number;
        brackets: number;
        upLimitEquality?: number;
        downLimitEquality?: number;
    }, errors: SemanticError[], upLimitVariable?: SemanticNode<T>, downLimitVariable?: SemanticNode<T>): T;
    visitIncludeSet(fexp: SemanticNode<T>, set: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitIndefiniteIntegral(integrand: SemanticNode<T>, differential: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitInfimum(operand: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitIntersection(left: SemanticNode<T>, right: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitInterval(type: IntervalType, leftBound: SemanticNode<T>, rightBound: SemanticNode<T>, symbols: {
        par: number;
        comma: number;
    }, errors: SemanticError[]): T;
    visitLeibnizDerivative(degree: number, operand: SemanticNode<T>, variable: SemanticNode<T>, leibnizDerivativeType: LeibnizDerivativeType, symbols: {
        fraction: number;
        numDif: number;
        denomDif: number;
        numDegree: number[];
        denomDegree: number[];
        numDegreeRightBoundary?: number;
        denomDegreeRightBoundary?: number;
        par?: number;
    }, errors: SemanticError[]): T;
    visitLimit(child: SemanticNode<T>, variable: SemanticNode<T>, to: SemanticNode<T>, limitType: LimitType, symbols: {
        lim: number;
        arrow: number;
        signIndex?: number;
        sign?: number;
    }, errors: SemanticError[]): T;
    visitLogarithm(operand: SemanticNode<T>, base: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitMathRoot(child: SemanticNode<T>, degree: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitMax(operands: ArgumentList<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitMin(operands: ArgumentList<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitMinus(left: SemanticNode<T>, right: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitMultiply(left: SemanticNode<T>, right: SemanticNode<T>, hidden: boolean, symbols: {
        op?: number;
    }, errors: SemanticError[]): T;
    visitNaturalLogarithmFunction(operand: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitNumericSet(name: NumSetLetters, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitOr(left: SemanticNode<T>, right: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitParentheses(child: SemanticNode<T>, symbols: {
        par: number;
    }, errors: SemanticError[]): T;
    visitPiecewiseFunction(elements: SemanticNode<T>[], predicates: SemanticNode<T>[], symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitPlaceholder(errorMessage: string, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitPlus(left: SemanticNode<T>, right: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitPoint(terms: ArgumentList<T>, symbols: {
        par: number;
    }, errors: SemanticError[]): T;
    visitPower(child: SemanticNode<T>, power: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitPredicate(expr: SemanticNode<T>, value: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitPrime(degree: number, child: SemanticNode<T>, symbols: {
        primes: number[];
    }, errors: SemanticError[]): T;
    visitProd(variable: SemanticNode<T>, from: SemanticNode<T>, to: SemanticNode<T>, child: SemanticNode<T>, symbols: {
        prod: number;
        equality: number;
    }, errors: SemanticError[]): T;
    visitRawText(text: string, symbols: {
        symbols: number[];
    }, errors: SemanticError[]): T;
    visitReversedFunction(child: SemanticNode<T>, symbols: {
        op: number;
        minus: number;
        one: number;
    }, errors: SemanticError[]): T;
    visitSet(fexp: SemanticNode<T>, set: ArgumentList<T>, symbols: {
        braces: number;
        border: number;
    }, errors: SemanticError[]): T;
    visitSquareMathRoot(child: SemanticNode<T>, symbols: {
        op: number;
        degree: number;
    }, errors: SemanticError[]): T;
    visitSubIndex(child: SemanticNode<T>, index: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitSum(variable: SemanticNode<T>, from: SemanticNode<T>, to: SemanticNode<T>, child: SemanticNode<T>, symbols: {
        sum: number;
        equality: number;
    }, errors: SemanticError[]): T;
    visitSupremum(operand: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitSystemOfEquations(elements: SemanticNode<T>[], symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitTransformation(left: SemanticNode<T>, right: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitTrigonometryFunction(name: TrigName, operand: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitUnaryMinus(child: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitUndefined(symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitUnion(left: SemanticNode<T>, right: SemanticNode<T>, symbols: {
        op: number;
    }, errors: SemanticError[]): T;
    visitUserFunction(operator: SemanticNode<T>, operands: ArgumentList<T>, symbols: {
        par: number;
    }, errors: SemanticError[]): T;
    visitValue(value: string, symbols: {
        symbols: number[];
    }, errors: SemanticError[]): T;
    visitVariable(name: string, isGreek: boolean, optionalIndex: ArgumentList<T>, symbols: {
        op: number;
        rightBoundary?: number;
    }, errors: SemanticError[]): T;
    visitVerticalBar(left: SemanticNode<T>, right: SemanticNode<T>, symbols: {
        symbol: number;
    }, errors: SemanticError[]): T;
}
export declare function convertToSemanticView<T>(node: AnyNode, semanticVisitor: SemanticVisitor<T>, semanticContext: SemanticContext): [T, SemanticError[]];
export declare class SemanticView<T> implements AnyNodeVisitor<T>, NonTerminalVisitor<T>, TerminalVisitor<T>, BinaryOperationNodeVisitor<T>, BracketsNodeVisitor<T> {
    private readonly semanticVisitor;
    private readonly semanticContext;
    private readonly prepareSemanticView;
    readonly structureErrors: SemanticError[];
    constructor(semanticVisitor: SemanticVisitor<T>, prepareSemanticView: PrepareSemanticView, semanticContext: SemanticContext);
    private wrap;
    private wrapResult;
    private onError;
    private wrapComma;
    visitTerminal(node: Terminal): T;
    visitNonTerminal(node: NonTerminal): T;
    visitEmptyset(node: EmptysetVariableNode): T;
    visitGreek(node: GreekVariableNode): T;
    visitLatin(node: LatinVariableNode): T;
    visitNumset(node: NumsetVariableNode): T;
    visitValue(node: ValueNode): T;
    private handleValue;
    visitRaw(node: RawNode): T;
    visitLim(node: LimNode): T;
    visitPlus(node: PlusNode): T;
    visitMinus(node: MinusNode): T;
    visitMultiply(node: MultiplyNode): T;
    visitIntersection(node: IntersectionSetNode): T;
    visitUnion(node: UnionSetNode): T;
    visitAnd(node: AndNode): T;
    visitOr(node: OrNode): T;
    visitInclude(node: IncludeSetNode): T;
    visitComma(node: CommaNode): T;
    visitVerticalBar(node: VerticalBarNode): T;
    visitBinaryOperation(node: BinaryOperationNode): T;
    visitNothing(node: NothingNode): T;
    visitRoot(node: RootNode): T;
    visitUnaryMinus(node: UnaryMinusNode): T;
    visitFunction(node: FuncNode): T;
    handleLeibnizDerivative(node: AnyNode, divide: DivideNode, operand: AnyNode, derivativeType: LeibnizDerivativeType, parentheses?: OpenBracketsNode): T;
    visitCell(node: AbstractCellNode): T;
    visitAbstractBrackets(node: AbstractBracketsNode): T;
    visitAbs(node: AbsNode): T;
    visitClosed(node: ClosedIntervalNode): T;
    visitLeftClosed(node: LeftClosedIntervalNode): T;
    visitMinMax(node: MinMaxNode): T;
    visitOpen(node: OpenBracketsNode): T;
    visitRightClosed(node: RightClosedIntervalNode): T;
    private handleBrackets;
    visitMathRoot(node: MathRootNode): T;
    visitSup(node: SupIndexNode): T;
    visitSupSub(node: SupSubIndexNode): T;
    private getDerivativeUp;
    visitSub(node: SubIndexNode): T;
    visitPrime(node: PrimeNode): T;
    private visitSimplePrime;
    visitDivide(node: DivideNode): T;
    visitInt(node: IntegralNode): T;
    visitConstant(node: ConstantNode): T;
    visitUndefined(node: UndefinedNode): T;
    visitLog(node: LogNode): T;
    visitProdOrSum(node: ProdOrSumNode): T;
    visitSet(node: SetNode): T;
    visitEquals(node: EqualsNode): T;
    visitNotEquals(node: NotEqualsNode): T;
    visitApproxEquals(node: ApproxEqualsNode): T;
    visitLessThan(node: LessThanNode): T;
    visitGreaterThan(node: GreaterThanNode): T;
    visitLessOrEquals(node: LessOrEqualsNode): T;
    visitGreaterOrEquals(node: GreaterOrEqualsNode): T;
    visitOperatorName(node: OperatorNameNode): T;
    visitPrivateTerminal(node: PrivateTerminal): T;
    visitPredicate(node: PredicateNode): T;
    visitDeterminant(node: DeterminantNode): T;
    visitSystemOfEquations(node: SystemOfEquationsNode): T;
    visitPiecewiseFunction(node: PiecewiseFunctionNode): T;
}
export declare class PrepareSemanticView implements AnyNodeVisitor<AnyNode | null>, NonTerminalVisitor<AnyNode | null>, TerminalVisitor<AnyNode | null>, BinaryOperationNodeVisitor<AnyNode | null>, BracketsNodeVisitor<AnyNode | null> {
    readonly errors: {
        node: AnyNode;
        error: SemanticError;
    }[];
    readonly limitTypes: {
        node: AnyNode;
        type: LimitTypeDefinition;
    }[];
    constructor();
    private onError;
    visitTerminal(node: Terminal): AnyNode | null;
    visitNonTerminal(node: NonTerminal): AnyNode | null;
    visitEmptyset(node: EmptysetVariableNode): AnyNode | null;
    visitGreek(node: GreekVariableNode): AnyNode | null;
    visitLatin(node: LatinVariableNode): AnyNode | null;
    visitNumset(node: NumsetVariableNode): AnyNode | null;
    visitValue(node: ValueNode): AnyNode | null;
    private handleValue;
    visitRaw(node: RawNode): AnyNode | null;
    convertLimitType(currNode: AnyNode, vg: VisualGraph, doConvert: boolean): LimitTypeDefinition;
    visitLim(node: LimNode): AnyNode | null;
    visitPlus(node: PlusNode): AnyNode | null;
    visitMinus(node: MinusNode): AnyNode | null;
    visitMultiply(node: MultiplyNode): AnyNode | null;
    visitIntersection(node: IntersectionSetNode): AnyNode | null;
    visitUnion(node: UnionSetNode): AnyNode | null;
    visitAnd(node: AndNode): AnyNode | null;
    visitOr(node: OrNode): AnyNode | null;
    visitInclude(node: IncludeSetNode): AnyNode | null;
    visitComma(node: CommaNode): AnyNode | null;
    visitVerticalBar(node: VerticalBarNode): AnyNode | null;
    visitBinaryOperation(node: BinaryOperationNode): AnyNode | null;
    visitNothing(node: NothingNode): AnyNode | null;
    visitRoot(node: RootNode): AnyNode | null;
    visitUnaryMinus(node: UnaryMinusNode): AnyNode | null;
    prepareFunction(node: FuncNode): AnyNode;
    visitFunction(node: FuncNode): AnyNode | null;
    handleLeibnizDerivative(node: AnyNode, divide: DivideNode, operand: AnyNode, derivativeType: LeibnizDerivativeType): boolean;
    visitCell(node: AbstractCellNode): AnyNode | null;
    visitAbstractBrackets(node: AbstractBracketsNode): AnyNode | null;
    visitAbs(node: AbsNode): AnyNode | null;
    visitClosed(node: ClosedIntervalNode): AnyNode | null;
    visitLeftClosed(node: LeftClosedIntervalNode): AnyNode | null;
    visitMinMax(node: MinMaxNode): AnyNode | null;
    visitOpen(node: OpenBracketsNode): AnyNode | null;
    visitRightClosed(node: RightClosedIntervalNode): AnyNode | null;
    private handleBrackets;
    visitMathRoot(node: MathRootNode): AnyNode | null;
    visitSup(node: SupIndexNode): AnyNode | null;
    visitSupSub(node: SupSubIndexNode): AnyNode | null;
    private prepareSup;
    private getDerivativeUp;
    visitSub(node: SubIndexNode): AnyNode | null;
    visitPrime(node: PrimeNode): AnyNode | null;
    visitDivide(node: DivideNode): AnyNode | null;
    visitInt(node: IntegralNode): AnyNode | null;
    visitConstant(node: ConstantNode): AnyNode | null;
    visitUndefined(node: UndefinedNode): AnyNode | null;
    visitLog(node: LogNode): AnyNode | null;
    visitProdOrSum(node: ProdOrSumNode): AnyNode | null;
    visitSet(node: SetNode): AnyNode | null;
    visitEquals(node: EqualsNode): AnyNode | null;
    visitNotEquals(node: NotEqualsNode): AnyNode | null;
    visitApproxEquals(node: ApproxEqualsNode): AnyNode | null;
    visitLessThan(node: LessThanNode): AnyNode | null;
    visitGreaterThan(node: GreaterThanNode): AnyNode | null;
    visitLessOrEquals(node: LessOrEqualsNode): AnyNode | null;
    visitGreaterOrEquals(node: GreaterOrEqualsNode): AnyNode | null;
    visitOperatorName(node: OperatorNameNode): AnyNode | null;
    visitPrivateTerminal(node: PrivateTerminal): AnyNode | null;
    visitPredicate(node: PredicateNode): AnyNode | null;
    visitDeterminant(node: DeterminantNode): AnyNode | null;
    visitSystemOfEquations(node: SystemOfEquationsNode): AnyNode | null;
    visitPiecewiseFunction(node: PiecewiseFunctionNode): AnyNode | null;
}
declare class LimitTypeDefinition {
    limitType: LimitType;
    signIndex?: number;
    sign?: number;
}
export declare class Term {
}
export declare class TraverseAllSemanticVisitor implements SemanticVisitor<void> {
    static readonly instance: TraverseAllSemanticVisitor;
    visitAbs(child: SemanticNode<void>, symbols: {
        par: number;
    }, errors: SemanticError[]): void;
    visitAnd(left: SemanticNode<void>, right: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitAreaIntegral(integrand: SemanticNode<void>, differential: SemanticNode<void>, area: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitBrackets(type: IntervalType, expression: SemanticNode<void>, symbols: {
        symbol: number;
    }, errors: SemanticError[]): void;
    visitComma(left: SemanticNode<void>, right: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitConstant(value: Constants, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitDefiniteIntegral(integrand: SemanticNode<void>, differential: SemanticNode<void>, downLimit: SemanticNode<void>, upLimit: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitDerivative(degree: number, child: SemanticNode<void>, symbols: {
        rightBoundary: number;
        parentheses: number;
        values: number[];
    }, errors: SemanticError[]): void;
    visitDeterminant(elements: SemanticNode<void>[][], symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitDifferential(child: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitDivide(numerator: SemanticNode<void>, denominator: SemanticNode<void>, symbols: {
        fraction: number;
    }, errors: SemanticError[]): void;
    visitEmptySet(symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitEqIneq(type: EqualityType, left: SemanticNode<void>, right: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitError(internalStructure: string, errorType: ErrorType, errorMessage: string, symbols: {
        internal: number[];
    }, errors: SemanticError[]): void;
    visitExpressionSet(set: ArgumentList<void>, symbols: {
        braces: number;
    }, errors: SemanticError[]): void;
    visitFunctionDifference(func: SemanticNode<void>, upLimit: SemanticNode<void>, downLimit: SemanticNode<void>, symbols: {
        op: number;
        brackets: number;
        upLimitEquality?: number;
        downLimitEquality?: number;
    }, errors: SemanticError[], upLimitVariable?: SemanticNode<void>, downLimitVariable?: SemanticNode<void>): void;
    visitIncludeSet(fexp: SemanticNode<void>, set: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitIndefiniteIntegral(integrand: SemanticNode<void>, differential: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitInfimum(operand: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitIntersection(left: SemanticNode<void>, right: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitInterval(type: IntervalType, leftBound: SemanticNode<void>, rightBound: SemanticNode<void>, symbols: {
        par: number;
        comma: number;
    }, errors: SemanticError[]): void;
    visitLeibnizDerivative(degree: number, operand: SemanticNode<void>, variable: SemanticNode<void>, leibnizDerivativeType: LeibnizDerivativeType, symbols: {
        fraction: number;
        numDif: number;
        denomDif: number;
        numDegree: number[];
        denomDegree: number[];
        par?: number;
    }, errors: SemanticError[]): void;
    visitLimit(child: SemanticNode<void>, variable: SemanticNode<void>, to: SemanticNode<void>, limitType: LimitType, symbols: {
        lim: number;
        arrow: number;
        signIndex?: number;
        sign?: number;
    }, errors: SemanticError[]): void;
    visitLogarithm(operand: SemanticNode<void>, base: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitMathRoot(child: SemanticNode<void>, degree: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitMax(operands: ArgumentList<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitMin(operands: ArgumentList<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitMinus(left: SemanticNode<void>, right: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitMultiply(left: SemanticNode<void>, right: SemanticNode<void>, hidden: boolean, symbols: {
        op?: number;
    }, errors: SemanticError[]): void;
    visitNaturalLogarithmFunction(operand: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitNumericSet(name: NumSetLetters, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitOr(left: SemanticNode<void>, right: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitParentheses(child: SemanticNode<void>, symbols: {
        par: number;
    }, errors: SemanticError[]): void;
    visitPiecewiseFunction(elements: SemanticNode<void>[], predicates: SemanticNode<void>[], symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitPlaceholder(errorMessage: string, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitPlus(left: SemanticNode<void>, right: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitPoint(terms: ArgumentList<void>, symbols: {
        par: number;
    }, errors: SemanticError[]): void;
    visitPower(child: SemanticNode<void>, power: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitPredicate(expr: SemanticNode<void>, value: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitPrime(degree: number, child: SemanticNode<void>, symbols: {
        primes: number[];
    }, errors: SemanticError[]): void;
    visitProd(variable: SemanticNode<void>, from: SemanticNode<void>, to: SemanticNode<void>, child: SemanticNode<void>, symbols: {
        prod: number;
        equality: number;
    }, errors: SemanticError[]): void;
    visitRawText(text: string, symbols: {
        symbols: number[];
    }, errors: SemanticError[]): void;
    visitReversedFunction(child: SemanticNode<void>, symbols: {
        op: number;
        minus: number;
        one: number;
    }, errors: SemanticError[]): void;
    visitSet(fexp: SemanticNode<void>, set: ArgumentList<void>, symbols: {
        braces: number;
        border: number;
    }, errors: SemanticError[]): void;
    visitSquareMathRoot(child: SemanticNode<void>, symbols: {
        op: number;
        degree: number;
    }, errors: SemanticError[]): void;
    visitSubIndex(child: SemanticNode<void>, index: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitSum(variable: SemanticNode<void>, from: SemanticNode<void>, to: SemanticNode<void>, child: SemanticNode<void>, symbols: {
        sum: number;
        equality: number;
    }, errors: SemanticError[]): void;
    visitSupremum(operand: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitSystemOfEquations(elements: SemanticNode<void>[], symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitTransformation(left: SemanticNode<void>, right: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitTrigonometryFunction(name: TrigName, operand: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitUnaryMinus(child: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitUndefined(symbols: {
        op: number;
    }): void;
    visitUnion(left: SemanticNode<void>, right: SemanticNode<void>, symbols: {
        op: number;
    }, errors: SemanticError[]): void;
    visitUserFunction(operator: SemanticNode<void>, operands: ArgumentList<void>, symbols: {
        par: number;
    }, errors: SemanticError[]): void;
    visitValue(value: string, symbols: {
        symbols: number[];
    }, errors: SemanticError[]): void;
    visitVariable(name: string, isGreek: boolean, optionalIndex: ArgumentList<void>, symbols: {
        op: number;
        rightBoundary?: number;
    }, errors: SemanticError[]): void;
    visitVerticalBar(left: SemanticNode<void>, right: SemanticNode<void>, symbols: {
        symbol: number;
    }, errors: SemanticError[]): void;
}
export declare enum IntervalType {
    open = "open",
    closed = "closed",
    leftClosed = "leftClosed",
    rightClosed = "rightClosed"
}
export {};
