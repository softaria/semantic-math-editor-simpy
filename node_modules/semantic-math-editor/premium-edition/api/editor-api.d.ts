/**
 * @hidden
 * @packageDocumentation
 */
import { SemanticError } from "../../standard-edition/model/errors";
import { UndoRedoEditor, UndoRedoEditorState } from "../../standard-edition/editor/undo-redo-editor";
import { MathStructure, MathSymbol } from "./model";
import { NavDirection, Stateful } from "../../standard-edition/editor/editor";
import { DomRenderedTree, DomRenderer } from "../../standard-edition/editor/editor-support";
import { ConfirmRequiredOperation } from "../../standard-edition/engine/internal-engine";
import { HorizontalDirection, VerticalDirection } from "../../standard-edition/engine/utils";
import { SemanticAdviceManager } from "./advice/semantic-advice-manager";
import { IAdvice } from "../../standard-edition/accessibility/advices";
import { NotifyInfo, NotifyObject, NotifyUpdateInfo, NotifyUpdateObject, TreeUpdateCallbacks } from "../../standard-edition/dom/dombinder-notify-updater";
import { DombinderA11ySpeaker } from "../../standard-edition/dom/dombinder-a11y-speaker";
import { SemanticDombinderNotifyUpdater } from "./semantic-dombinder-notify-updater";
import { MathNodeValidationVisitor } from "./util/validation";
import { Heuristic } from "./util/heuristics";
import { MathTreeSettings } from "./util/utils";
import { CursorNode, CursorSide } from "../../standard-edition/dom/mouse-selection";
/**
 * @category API
 */
export declare class MathTree {
    readonly editor: UndoRedoEditor & Stateful<UndoRedoEditorState>;
    heuristics: Heuristic[];
    readonly updateNotifier: SemanticDombinderNotifyUpdater;
    readonly speaker: DombinderA11ySpeaker;
    semanticValidationVisitor: MathNodeValidationVisitor;
    constructor(editor: UndoRedoEditor & Stateful<UndoRedoEditorState>, callbacks?: MathTreeCallbacks);
    applyHeuristics(): boolean;
    getCursor(): Cursor;
    filterSymbolsAtCursor(symbolIds: number[], includeHidden?: boolean): number[];
    placeCursor(nodeId: number, side: CursorSide): MathTree;
    protected notifyOnUpdate(updateType: NotifyUpdateObject | NotifyUpdateObject[], confirmation?: ConfirmRequiredOperation, calledInsideOnUpdate?: boolean): void;
    protected notifyOnSemanticUpdate(updateType: MathUpdateObject | MathUpdateObject[], confirmation?: ConfirmRequiredOperation, calledInsideOnUpdate?: boolean): void;
    protected notify(updateType: NotifyObject | NotifyObject[], confirmation?: ConfirmRequiredOperation, calledInsideOnUpdate?: boolean): void;
    addOnUpdate(cb: (updateInfo: NotifyUpdateInfo, confirmation: ConfirmRequiredOperation) => void): void;
    removeOnUpdate(cb: (updateInfo: NotifyUpdateInfo, confirmation: ConfirmRequiredOperation) => void): void;
    addOnSemanticUpdate(cb: (updateInfo: MathNotifyUpdateInfo) => void): void;
    removeOnSemanticUpdate(cb: (updateInfo: MathNotifyUpdateInfo) => void): void;
    addOnNotify(cb: (updateInfo: NotifyInfo) => void): void;
    removeOnNotify(cb: (updateInfo: NotifyInfo) => void): void;
    removeCursor(): MathTree;
    getSemanticSpeech(): string;
    getChararcterSpeech(): string;
    getLatex(): string;
    getTree(settings?: MathTreeSettings): MathStructure;
    getInternalStructure(): string;
    getSemanticText(): string;
    getSemantic(): {
        semantic: MathStructure;
        errors: SemanticErrorDescription[];
    };
    insertSymbol(s: string): MathTree;
    private insertNode;
    insertGreekSymbol(s: string): MathTree;
    insertNumSetSymbol(s: string): MathTree;
    insertEmptySetSymbol(): MathTree;
    insertUndefined(): MathTree;
    insertTrig(name: string): MathTree;
    insertLim(): MathTree;
    insertLog(): MathTree;
    insertSqrt(): MathTree;
    insertPi(): MathTree;
    insertInfinity(): MathTree;
    insertLn(): MathTree;
    insertProd(): MathTree;
    insertSum(): MathTree;
    deleteOneAtCursor(direction: HorizontalDirection, force?: boolean): this;
    copy(): string;
    cut(): string;
    paste(latex: string): MathTree;
    navigate(direction: NavDirection): boolean;
    select(direction: NavDirection): MathTree;
    selectByNodeIds(horizontalDirection: HorizontalDirection, verticalDirection: VerticalDirection, startPointer: CursorNode, endNodeId: number): MathTree;
    getBoundaryTerminal(left: boolean, onlyVisible?: boolean): number;
    getBoundaryPointer(left: boolean, onlyVisible?: boolean): CursorNode;
    getSelectionBoundaryTerminal(horizontalDirection: HorizontalDirection, verticalDirection?: VerticalDirection): number;
    getSelectionBoundaryPointer(horizontalDirection: HorizontalDirection, verticalDirection?: VerticalDirection): CursorNode;
    moveSelectionHorizontalBoundary(leftBoundary: boolean, direction: HorizontalDirection): MathTree;
    moveSelectionVerticalBoundary(topBoundary: boolean, direction: VerticalDirection): MathTree;
    getSelectionTree(): MathStructure;
    hasSelection(): boolean;
    getSelectionHorizontalDirection(): HorizontalDirection;
    dropSelection(placeCursorAtSelectionEnd: boolean): void;
    undo(): MathTree;
    redo(): MathTree;
    wrapWithTransformation(): void;
    setTree(tree: MathStructure): MathStructure;
    insertTreeAtCursor(tree: MathStructure, overrideContext?: boolean): void;
    /**
     * Returns an array of node ids, ordered left to right according to initial order in the math expression
     */
    setInternalStructure(mathExpression: string): number[];
    defineEditableCell(editableCells: {
        nodeId: number;
        borderVisible?: boolean;
        avoidParenthesesWrap?: boolean;
    }[]): MathTree;
    pauseSync(): void;
    resumeSync(insideOnUpdate: boolean): void;
}
export interface MathTreeCallbacks extends TreeUpdateCallbacks {
    onSemanticUpdate?: (updateInfo: MathNotifyUpdateInfo) => void;
}
export declare class MathNotifyUpdateInfo {
    objects: MathUpdateObject[];
    constructor(objects: MathUpdateObject[]);
}
export declare enum MathUpdateObject {
    validation = "validation"
}
/**
 * @category API
 */
export declare class MathEditorAPI extends MathTree {
    protected readonly renderer: DomRenderer;
    protected readonly adviceManager: SemanticAdviceManager;
    protected renderedTree: DomRenderedTree;
    private decorations;
    constructor(editor: UndoRedoEditor & Stateful<UndoRedoEditorState>, renderer: DomRenderer, adviceManager: SemanticAdviceManager, callbacks?: MathTreeCallbacks);
    /**
     * @param {VerticalDirection} direction
     * @return {boolean} true if navigation happened (there was somewhere to go)
     */
    navigateVertically(direction: VerticalDirection): boolean;
    getAdvices(): IAdvice[];
    selectAdvice(advice: IAdvice): this;
    decorateNodes(nodeIds: number[], decorator: (element: HTMLElement) => void, preDelete?: () => void, withRender?: boolean, omitRedraw?: boolean): () => void;
    renderDecorationsOnly(): void;
    cleanDecorations(): void;
    cleanEditorWithoutNotify(): void;
    toggleInputSymbolsReading(value: boolean): void;
    showValidation(): void;
    getCursorBoundingRect(): ClientRect;
    getSelectionBoundingRect(): ClientRect[];
    getDOMElement(nodeId: number): Element[];
    saveCurrentState(): string;
    restoreCurrentState(state: string): void;
    saveStateWithHistory(): string;
    restoreStateWithHistory(state: string): void;
    protected render(decorationOnly?: boolean): void;
    private getTerminals;
}
export declare class Cursor {
    readonly leftNode: MathSymbol;
    readonly rightNode: MathSymbol;
    readonly anyNode: MathSymbol;
    readonly anySide: CursorSide;
    readonly atBaseLevel: boolean;
    constructor(leftNode: MathSymbol, rightNode: MathSymbol, atBaseLevel: boolean);
    get isEmpty(): boolean;
}
export declare class SemanticErrorDescription {
    readonly uuid: string;
    readonly nodeIds: number[];
    readonly description: string;
    constructor(nodeIds: number[], description: string);
}
export declare function convertSemanticError(semanticError: SemanticError): SemanticErrorDescription;
