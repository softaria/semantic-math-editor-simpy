/**
 * @hidden
 * @packageDocumentation
 *
 */
import { SemanticError } from "../../standard-edition/model/errors";
export declare enum MathNodeType {
    symbol = "symbol",
    structure = "structure"
}
export declare enum MathNodeName {
    variable = "variable",
    number = "number",
    constant = "constant",
    numericSet = "numericSet",
    emptySet = "emptySet",
    undefined = "undefined",
    logarithm = "logarithm",
    naturalLogarithm = "naturalLogarithm",
    limit = "limit",
    predicate = "predicate",
    rawText = "rawText",
    plus = "plus",
    multiply = "multiply",
    implicitMultiply = "implicitMultiply",
    minus = "minus",
    union = "union",
    intersection = "intersection",
    and = "and",
    or = "or",
    unaryMinus = "unaryMinus",
    root = "root",
    squareRoot = "squareRoot",
    power = "power",
    reversedFunction = "reversedFunction",
    division = "division",
    equality = "equality",
    transformation = "transformation",
    function = "function",
    trigonometricFunction = "trigonometricFunction",
    differential = "differential",
    infimum = "infimum",
    supremum = "supremum",
    indefiniteIntegral = "indefiniteIntegral",
    definiteIntegral = "definiteIntegral",
    areaIntegral = "areaIntegral",
    functionDifference = "functionDifference",
    product = "product",
    sum = "sum",
    min = "min",
    max = "max",
    abs = "abs",
    parentheses = "parentheses",
    interval = "interval",
    point = "point",
    derivative = "derivative",
    leibnizDerivative = "leibnizDerivative",
    determinant = "determinant",
    systemOfEquations = "systemOfEquations",
    piecewiseFunction = "piecewiseFunction",
    set = "set",
    expressionSet = "expressionSet",
    includeSet = "includeSet",
    symbol = "symbol",
    brackets = "brackets",
    comma = "comma",
    subIndex = "subIndex",
    verticalBar = "verticalBar",
    placeholder = "placeholder"
}
export declare enum MathConstants {
    e = "e",
    pi = "pi",
    infinity = "infinity",
    imaginaryUnit = "imaginaryUnit",
    complexInfinity = "complexInfinity"
}
/**
 * @category Model
 */
export declare abstract class MathNode {
    readonly type: MathNodeType;
    readonly name: MathNodeName;
    constructor(type: MathNodeType, name: MathNodeName);
}
/**
 * @category Model
 */
export declare abstract class MathStructure extends MathNode {
    symbols: {
        [name: string]: MathSymbol | MathSymbol[] | undefined;
    };
    errors: SemanticError[];
    cell?: boolean;
    cellBorderVisible?: boolean;
    cellAvoidParenthesesWrap?: boolean;
    constructor(name: MathNodeName, errors: SemanticError[]);
}
export declare abstract class MathError extends MathStructure {
}
/**
 * @description Special case of MathError usable as a shortcut to create new empty tree.
 */
export declare class MathPlaceholder extends MathError {
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathSymbol extends MathNode {
    nodeId: number;
    leftCursor?: boolean;
    rightCursor?: boolean;
    constructor(nodeId?: number);
}
export declare class MathVariable extends MathStructure {
    value: string;
    indexes: MathStructure[];
    isGreek: boolean;
    symbols: {
        variable?: MathSymbol;
        rightBoundary?: MathSymbol;
        comma: MathSymbol[];
    };
    constructor(value: string, isGreek: boolean, indexes?: MathStructure[], variableSymbol?: MathSymbol, rightBoundary?: MathSymbol, commaSymbols?: MathSymbol[], errors?: SemanticError[]);
}
export declare class MathNumber extends MathStructure {
    value: string;
    symbols: {
        symbols: MathSymbol[];
    };
    constructor(value: string, symbols?: MathSymbol[], errors?: SemanticError[]);
}
export declare class MathConstant extends MathStructure {
    value: MathConstants;
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(value: MathConstants, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare enum MathNumericSetValues {
    C = "C",
    N = "N",
    Q = "Q",
    R = "R",
    Z = "Z"
}
export declare class MathNumericSet extends MathStructure {
    value: MathNumericSetValues;
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(value: MathNumericSetValues, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathEmptySet extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathUndefined extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathLimit extends MathStructure {
    func: MathStructure;
    input: MathStructure;
    value: MathStructure;
    limitType: MathLimitType;
    symbols: {
        limit?: MathSymbol;
        arrow?: MathSymbol;
        signIndex?: MathSymbol;
        sign?: MathSymbol;
    };
    constructor(func: MathStructure, input: MathStructure, value: MathStructure, limitType: MathLimitType, limitSymbol?: MathSymbol, arrowSymbol?: MathSymbol, signIndex?: MathSymbol, sign?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathProduct extends MathStructure {
    sequence: MathStructure;
    index: MathStructure;
    lowerBound: MathStructure;
    upperBound: MathStructure;
    symbols: {
        product?: MathSymbol;
        equality?: MathSymbol;
    };
    constructor(sequence: MathStructure, index: MathStructure, lowerBound: MathStructure, upperBound: MathStructure, productSymbol?: MathSymbol, eqSymbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathSum extends MathStructure {
    sequence: MathStructure;
    index: MathStructure;
    lowerBound: MathStructure;
    upperBound: MathStructure;
    symbols: {
        sum?: MathSymbol;
        equality?: MathSymbol;
    };
    constructor(sequence: MathStructure, index: MathStructure, lowerBound: MathStructure, upperBound: MathStructure, sumSymbol?: MathSymbol, eqSymbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathMin extends MathStructure {
    operands: MathStructure[];
    symbols: {
        min?: MathSymbol;
        comma: MathSymbol[];
    };
    constructor(operands: MathStructure[], symbol?: MathSymbol, comma?: MathSymbol[], errors?: SemanticError[]);
}
export declare class MathMax extends MathStructure {
    operands: MathStructure[];
    symbols: {
        max?: MathSymbol;
        comma: MathSymbol[];
    };
    constructor(operands: MathStructure[], symbol?: MathSymbol, comma?: MathSymbol[], errors?: SemanticError[]);
}
export declare class MathInfimum extends MathStructure {
    operand: MathStructure;
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(operands: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathSupremum extends MathStructure {
    operand: MathStructure;
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(operands: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathLogarithm extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    base: MathStructure;
    operand: MathStructure;
    constructor(base: MathStructure, operand: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathNaturalLogarithm extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    operand: MathStructure;
    constructor(operand: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare const MathPredicateAllowedSymbols = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789:;., ";
export declare class MathPredicate extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    value: MathStructure;
    constructor(left: MathStructure, value: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathPlus extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathMultiply extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathImplicitMultiply extends MathStructure {
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, errors?: SemanticError[]);
}
export declare class MathUnion extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathIntersection extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathAnd extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathOr extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathParentheses extends MathStructure {
    expression: MathStructure;
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(expression: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathBrackets extends MathError {
    expression: MathStructure;
    bracketsType: MathBracketsType;
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(bracketsType: MathBracketsType, expression: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathComma extends MathError {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathRawText extends MathStructure {
    text: string;
    symbols: {
        symbols: MathSymbol[];
    };
    constructor(text: string, symbols?: MathSymbol[], errors?: SemanticError[]);
}
export declare class MathVerticalBar extends MathError {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathAbs extends MathStructure {
    expression: MathStructure;
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(expression: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare enum MathBracketsType {
    open = "open",
    closed = "closed",
    leftClosed = "leftClosed",
    rightClosed = "rightClosed"
}
export declare class MathInterval extends MathStructure {
    intervalType: MathBracketsType;
    leftBound: MathStructure;
    rightBound: MathStructure;
    symbols: {
        parentheses?: MathSymbol;
        comma?: MathSymbol;
    };
    constructor(intervalType: MathBracketsType, leftBound: MathStructure, rightBound: MathStructure, parenSymbol?: MathSymbol, commaSymbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathPoint extends MathStructure {
    terms: MathStructure[];
    symbols: {
        parentheses?: MathSymbol;
        commas: MathSymbol[];
    };
    constructor(terms: MathStructure[], parenthesesSymbol?: MathSymbol, commaSymbols?: MathSymbol[], errors?: SemanticError[]);
}
export declare class MathIncludeSet extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    fexp: MathStructure;
    set: MathStructure;
    constructor(fexp: MathStructure, set: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathSet extends MathStructure {
    fexp: MathStructure;
    set: MathStructure[];
    symbols: {
        parentheses?: MathSymbol;
        border?: MathSymbol;
        comma: MathSymbol[];
    };
    constructor(fexp: MathStructure, set: MathStructure[], parenSymbol?: MathSymbol, borderSymbol?: MathSymbol, commaSymbols?: MathSymbol[], errors?: SemanticError[]);
}
export declare class MathExpressionSet extends MathStructure {
    set: MathStructure[];
    symbols: {
        parentheses?: MathSymbol;
        comma: MathSymbol[];
    };
    constructor(set: MathStructure[], parenSymbol?: MathSymbol, commaSymbols?: MathSymbol[], errors?: SemanticError[]);
}
export declare class MathMinus extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathUnaryMinus extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    expression: MathStructure;
    constructor(expression: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathRoot extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    base: MathStructure;
    degree: MathStructure;
    constructor(base: MathStructure, degree: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathSquareRoot extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
        degree?: MathSymbol;
    };
    base: MathStructure;
    constructor(base: MathStructure, symbol?: MathSymbol, degree?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathPower extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    base: MathStructure;
    exponent: MathStructure;
    constructor(base: MathStructure, exponent: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathSubIndex extends MathError {
    symbols: {
        symbol?: MathSymbol;
    };
    base: MathStructure;
    index: MathStructure;
    constructor(base: MathStructure, index: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathReversedFunction extends MathStructure {
    base: MathStructure;
    symbols: {
        rightBoundary?: MathSymbol;
        minus?: MathSymbol;
        one?: MathSymbol;
    };
    constructor(base: MathStructure, rightBoundarySymbol?: MathSymbol, minusSymbol?: MathSymbol, oneSymbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathDivision extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    numerator: MathStructure;
    denominator: MathStructure;
    constructor(numerator: MathStructure, denominator: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare enum MathEqualityType {
    equals = "equals",
    lessThan = "lessThan",
    greaterThan = "greaterThan",
    lessOrEquals = "lessOrEquals",
    greaterOrEquals = "greaterOrEquals",
    notEquals = "notEquals",
    approxEquals = "approxEquals"
}
export declare class MathEquality extends MathStructure {
    equalityType: MathEqualityType;
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(equalityType: MathEqualityType, left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathTransformation extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    left: MathStructure;
    right: MathStructure;
    constructor(left: MathStructure, right: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare enum MathTrigonometryType {
    sin = "sin",
    cos = "cos",
    tan = "tan",
    csc = "csc",
    sec = "sec",
    cot = "cot",
    arcsin = "arcsin",
    arccos = "arccos",
    arctan = "arctan",
    arccsc = "arccsc",
    arcsec = "arcsec",
    arccot = "arccot",
    sinh = "sinh",
    cosh = "cosh",
    tanh = "tanh",
    arcsinh = "arcsinh",
    arccosh = "arccosh",
    arctanh = "arctanh"
}
export declare class MathTrigonometricFunction extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    funcName: MathTrigonometryType;
    operand: MathStructure;
    constructor(funcName: MathTrigonometryType, operand: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathFunction extends MathStructure {
    operator: MathStructure;
    operands: MathStructure[];
    symbols: {
        parentheses?: MathSymbol;
        comma: MathSymbol[];
    };
    constructor(operator: MathStructure, operands: MathStructure[], parenthesesSymbol?: MathSymbol, commaSymbols?: MathSymbol[], errors?: SemanticError[]);
}
export declare class MathDifferential extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    expression: MathStructure;
    constructor(expression: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathDefiniteIntegral extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    expression: MathStructure;
    differential: MathStructure;
    lowerBound: MathStructure;
    upperBound: MathStructure;
    constructor(expression: MathStructure, differential: MathStructure, lowerBound: MathStructure, upperBound: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathIndefiniteIntegral extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    expression: MathStructure;
    differential: MathStructure;
    constructor(expression: MathStructure, differential: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathAreaIntegral extends MathStructure {
    symbols: {
        symbol?: MathSymbol;
    };
    expression: MathStructure;
    differential: MathStructure;
    area: MathStructure;
    constructor(expression: MathStructure, differential: MathStructure, area: MathStructure, symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathFunctionDifference extends MathStructure {
    func: MathStructure;
    upLimitValue: MathStructure;
    downLimitValue: MathStructure;
    upLimitVariable?: MathStructure;
    downLimitVariable?: MathStructure;
    symbols: {
        rightBoundary?: MathSymbol;
        brackets?: MathSymbol;
        upLimitEqulaity?: MathSymbol;
        downLimitEquality?: MathSymbol;
    };
    constructor(func: MathStructure, upLimitValue: MathStructure, downLimitValue: MathStructure, upLimitVariable?: MathStructure, downLimitVariable?: MathStructure, rightBoundarySymbol?: MathSymbol, bracketsSymbol?: MathSymbol, upLimitEqulaitySymbol?: MathSymbol, downLimitEqualitySymbol?: MathSymbol, errors?: SemanticError[]);
}
export declare enum MathDerivativeType {
    prime = "prime",
    number = "number"
}
export declare class MathDerivative extends MathStructure {
    base: MathStructure;
    degree: number;
    derivativeType: MathDerivativeType;
    symbols: {
        primes: MathSymbol[];
        rightBoundary?: MathSymbol;
        parentheses?: MathSymbol;
        values: MathSymbol[];
    };
    constructor(base: MathStructure, degree: number, derivativeType: MathDerivativeType, primes?: MathSymbol[], rightBoundary?: MathSymbol, parentheses?: MathSymbol, values?: MathSymbol[], errors?: SemanticError[]);
}
export declare enum MathLeibnizDerivativeType {
    basic = "basic",
    withParentheses = "withParentheses"
}
export declare enum MathLimitType {
    unspecified = "unspecified",
    left = "left",
    right = "right"
}
export declare class MathLeibnizDerivative extends MathStructure {
    degree: number;
    operand: MathStructure;
    variable: MathStructure;
    leibnizDerivativeType: MathLeibnizDerivativeType;
    symbols: {
        fraction?: MathSymbol;
        numeratorDiff?: MathSymbol;
        denominatorDiff?: MathSymbol;
        numeratorDegree: MathSymbol[];
        numDegreeRightBoundary?: MathSymbol;
        denominatorDegree: MathSymbol[];
        denomDegreeRightBoundary?: MathSymbol;
        parentheses?: MathSymbol;
    };
    constructor(degree: number, operand: MathStructure, variable: MathStructure, leibnizDerivativeType: MathLeibnizDerivativeType, fractionSymbol?: MathSymbol, numeratorDiff?: MathSymbol, denominatorDiff?: MathSymbol, numeratorDegree?: MathSymbol[], numDegreeRightBoundary?: MathSymbol, denominatorDegree?: MathSymbol[], denomDegreeRightBoundary?: MathSymbol, parentheses?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathDeterminant extends MathStructure {
    elements: MathStructure[][];
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(elements: MathStructure[][], symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathSystemOfEquations extends MathStructure {
    elements: MathStructure[];
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(elements: MathStructure[], symbol?: MathSymbol, errors?: SemanticError[]);
}
export declare class MathPiecewiseFunction extends MathStructure {
    elements: MathStructure[];
    predicates: MathStructure[];
    symbols: {
        symbol?: MathSymbol;
    };
    constructor(elements: MathStructure[], predicates: MathStructure[], symbol?: MathSymbol, errors?: SemanticError[]);
}
export interface MathNodeVisitor<T> {
    visitAbs(mathNode: MathAbs): T;
    visitAnd(mathNode: MathAnd): T;
    visitAreaIntegral(mathNode: MathAreaIntegral): T;
    visitBrackets(mathNode: MathBrackets): T;
    visitComma(mathNode: MathComma): T;
    visitConstant(mathNode: MathConstant): T;
    visitDefiniteIntegral(mathNode: MathDefiniteIntegral): T;
    visitDerivative(mathNode: MathDerivative): T;
    visitDeterminant(mathNode: MathDeterminant): T;
    visitDifferential(mathNode: MathDifferential): T;
    visitDivision(mathNode: MathDivision): T;
    visitEmptySet(mathNode: MathEmptySet): T;
    visitEquality(mathNode: MathEquality): T;
    visitExpressionSet(mathNode: MathExpressionSet): T;
    visitFunction(mathNode: MathFunction): T;
    visitFunctionDifference(mathNode: MathFunctionDifference): T;
    visitImplicitMultiply(mathNode: MathImplicitMultiply): T;
    visitIncludeSet(mathNode: MathIncludeSet): T;
    visitIndefiniteIntegral(mathNode: MathIndefiniteIntegral): T;
    visitInfimum(mathNode: MathInfimum): T;
    visitIntersection(mathNode: MathIntersection): T;
    visitInterval(mathNode: MathInterval): T;
    visitLeibnizDerivative(mathNode: MathLeibnizDerivative): T;
    visitLimit(mathNode: MathLimit): T;
    visitLogarithm(mathNode: MathLogarithm): T;
    visitMax(mathNode: MathMax): T;
    visitMin(mathNode: MathMin): T;
    visitMinus(mathNode: MathMinus): T;
    visitMultiply(mathNode: MathMultiply): T;
    visitNaturalLogarithm(mathNode: MathNaturalLogarithm): T;
    visitNumber(mathNode: MathNumber): T;
    visitNumericSet(mathNode: MathNumericSet): T;
    visitOr(mathNode: MathOr): T;
    visitParentheses(mathNode: MathParentheses): T;
    visitPiecewiseFunction(mathNode: MathPiecewiseFunction): T;
    visitPlaceholder(mathNode: MathPlaceholder): T;
    visitPlus(mathNode: MathPlus): T;
    visitPoint(mathNode: MathPoint): T;
    visitPower(mathNode: MathPower): T;
    visitPredicate(mathNode: MathPredicate): T;
    visitProduct(mathNode: MathProduct): T;
    visitRawText(mathNode: MathRawText): T;
    visitReversedFunction(mathNode: MathReversedFunction): T;
    visitRoot(mathNode: MathRoot): T;
    visitSet(mathNode: MathSet): T;
    visitSquareRoot(mathNode: MathSquareRoot): T;
    visitSubIndex(mathNode: MathSubIndex): T;
    visitSum(mathNode: MathSum): T;
    visitSupremum(mathNode: MathSupremum): T;
    visitSymbol(mathNode: MathSymbol): T;
    visitSystemOfEquations(mathNode: MathSystemOfEquations): T;
    visitTransformation(mathNode: MathTransformation): T;
    visitTrigonometricFunction(mathNode: MathTrigonometricFunction): T;
    visitUnaryMinus(mathNode: MathUnaryMinus): T;
    visitUndefined(mathNode: MathUndefined): T;
    visitUnion(mathNode: MathUnion): T;
    visitVariable(mathNode: MathVariable): T;
    visitVerticalBar(mathNode: MathVerticalBar): T;
}
