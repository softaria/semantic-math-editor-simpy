/**
 * @hidden
 * @packageDocumentation
 */
declare enum AssocType {
    left = "left",
    right = "right"
}
interface TokenVisitor<T> {
    visitOperator(token: OperatorToken): T;
    visitFunction(token: FunctionToken): T;
    visitVariable(token: VariableToken): T;
    visitLiteral(token: LiteralToken): T;
    visitString(token: StringToken): T;
    visitPar(token: ParToken): T;
}
export declare abstract class Token {
    readonly value: string;
    constructor(value: string);
    abstract accept<T>(visitor: TokenVisitor<T>): T;
    abstract toString(): string;
}
interface NonTerminalToken {
    acceptNonTerminalTokenVisitor<T>(visitor: NonTerminalTokenVisitor<T>): T;
}
interface NonTerminalTokenVisitor<T> {
    visitOperator(token: OperatorToken): T;
    visitFunction(token: FunctionToken): T;
    visitPar(token: ParToken): T;
}
declare class LiteralToken extends Token {
    accept<T>(visitor: TokenVisitor<T>): T;
    toString(): string;
}
declare class VariableToken extends Token {
    accept<T>(visitor: TokenVisitor<T>): T;
    toString(): string;
}
declare class StringToken extends Token {
    accept<T>(visitor: TokenVisitor<T>): T;
    toString(): string;
}
declare class FunctionToken extends Token implements NonTerminalToken {
    accept<T>(visitor: TokenVisitor<T>): T;
    acceptNonTerminalTokenVisitor<T>(visitor: NonTerminalTokenVisitor<T>): T;
    toString(): string;
}
declare class ParToken extends Token implements NonTerminalToken {
    accept<T>(visitor: TokenVisitor<T>): T;
    get left(): boolean;
    acceptNonTerminalTokenVisitor<T>(visitor: NonTerminalTokenVisitor<T>): T;
    toString(): string;
}
declare class OperatorToken extends Token implements NonTerminalToken {
    readonly value: string;
    isUnary: boolean;
    constructor(value: string);
    precedence(): number;
    associativity(): AssocType;
    accept<T>(visitor: TokenVisitor<T>): T;
    acceptNonTerminalTokenVisitor<T>(visitor: NonTerminalTokenVisitor<T>): T;
    toString(): string;
}
export interface AstNodeVisitor<T> {
    visitUnaryOperator(value: string, child: ASTNode): T;
    visitPar(child: ASTNode): T;
    visitOperator(name: string, left: ASTNode, right: ASTNode): T;
    visitVariable(name: string, indexes: ASTNode[]): T;
    visitLiteral(value: string): T;
    visitFunction(name: string, children: ASTNode[]): T;
    visitString(s: string): T;
}
export declare class ASTNode {
    readonly token: Token;
    readonly children: ASTNode[];
    constructor(token: Token, children?: ASTNode[]);
    accept<T>(visitor: AstNodeVisitor<T>): T;
    processArgs(node: ASTNode): ASTNode[];
}
export declare function parseExpression(inp: string, _log?: boolean): ASTNode;
export {};
