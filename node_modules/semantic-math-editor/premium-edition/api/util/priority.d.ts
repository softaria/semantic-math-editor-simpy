/**
 * @hidden
 * @packageDocumentation
 */
import { MathAbs, MathAnd, MathAreaIntegral, MathBrackets, MathComma, MathConstant, MathDefiniteIntegral, MathDerivative, MathDeterminant, MathDifferential, MathDivision, MathEmptySet, MathEquality, MathExpressionSet, MathFunction, MathFunctionDifference, MathImplicitMultiply, MathIncludeSet, MathIndefiniteIntegral, MathInfimum, MathIntersection, MathInterval, MathLeibnizDerivative, MathLimit, MathLogarithm, MathMax, MathMin, MathMinus, MathMultiply, MathNaturalLogarithm, MathNodeVisitor, MathNumber, MathNumericSet, MathOr, MathParentheses, MathPiecewiseFunction, MathPlaceholder, MathPlus, MathPoint, MathPower, MathPredicate, MathProduct, MathRawText, MathReversedFunction, MathRoot, MathSet, MathSquareRoot, MathStructure, MathSubIndex, MathSum, MathSupremum, MathSymbol, MathSystemOfEquations, MathTransformation, MathTrigonometricFunction, MathUnaryMinus, MathUndefined, MathUnion, MathVariable, MathVerticalBar } from "../model";
export declare enum MathOperationPriority {
    transformation = 0,
    verticalBar = 1,
    comma = 2,
    isStatement = 3,
    orOperation = 4,
    andOperation = 5,
    equalityOperation = 6,
    include = 7,
    setOperation = 8,
    plusAndMinus = 9,
    unaryMinus = 10,
    multiply = 11,
    openRight = 12,
    openLeft = 13,
    join = 14
}
export declare class MathNodePriority {
    left?: {
        child: MathStructure;
        priority: MathOperationPriority;
    };
    right?: {
        child: MathStructure;
        priority: MathOperationPriority;
    };
    private constructor();
    static createBoth(leftChild: MathStructure, rightChild: MathStructure, priority: MathOperationPriority): MathNodePriority;
    static createLeft(child: MathStructure, priority: MathOperationPriority): MathNodePriority;
    static createNone(): MathNodePriority;
    static createRight(child: MathStructure, priority: MathOperationPriority): MathNodePriority;
}
export declare class MathNodeLeftRightChildVisitor implements MathNodeVisitor<MathNodePriority> {
    static instance: MathNodeLeftRightChildVisitor;
    visitAbs(mathNode: MathAbs): MathNodePriority;
    visitAnd(mathNode: MathAnd): MathNodePriority;
    visitAreaIntegral(mathNode: MathAreaIntegral): MathNodePriority;
    visitBrackets(mathNode: MathBrackets): MathNodePriority;
    visitComma(mathNode: MathComma): MathNodePriority;
    visitConstant(mathNode: MathConstant): MathNodePriority;
    visitDefiniteIntegral(mathNode: MathDefiniteIntegral): MathNodePriority;
    visitDerivative(mathNode: MathDerivative): MathNodePriority;
    visitDeterminant(mathNode: MathDeterminant): MathNodePriority;
    visitDifferential(mathNode: MathDifferential): MathNodePriority;
    visitDivision(mathNode: MathDivision): MathNodePriority;
    visitEmptySet(mathNode: MathEmptySet): MathNodePriority;
    visitEquality(mathNode: MathEquality): MathNodePriority;
    visitExpressionSet(mathNode: MathExpressionSet): MathNodePriority;
    visitFunction(mathNode: MathFunction): MathNodePriority;
    visitFunctionDifference(mathNode: MathFunctionDifference): MathNodePriority;
    visitImplicitMultiply(mathNode: MathImplicitMultiply): MathNodePriority;
    visitIncludeSet(mathNode: MathIncludeSet): MathNodePriority;
    visitIndefiniteIntegral(mathNode: MathIndefiniteIntegral): MathNodePriority;
    visitInfimum(mathNode: MathInfimum): MathNodePriority;
    visitIntersection(mathNode: MathIntersection): MathNodePriority;
    visitInterval(mathNode: MathInterval): MathNodePriority;
    visitPoint(mathNode: MathPoint): MathNodePriority;
    visitLeibnizDerivative(mathNode: MathLeibnizDerivative): MathNodePriority;
    visitLimit(mathNode: MathLimit): MathNodePriority;
    visitLogarithm(mathNode: MathLogarithm): MathNodePriority;
    visitMax(mathNode: MathMax): MathNodePriority;
    visitMin(mathNode: MathMin): MathNodePriority;
    visitMinus(mathNode: MathMinus): MathNodePriority;
    visitMultiply(mathNode: MathMultiply): MathNodePriority;
    visitNaturalLogarithm(mathNode: MathNaturalLogarithm): MathNodePriority;
    visitNumber(mathNode: MathNumber): MathNodePriority;
    visitNumericSet(mathNode: MathNumericSet): MathNodePriority;
    visitOr(mathNode: MathOr): MathNodePriority;
    visitParentheses(mathNode: MathParentheses): MathNodePriority;
    visitPiecewiseFunction(mathNode: MathPiecewiseFunction): MathNodePriority;
    visitPlaceholder(mathNode: MathPlaceholder): MathNodePriority;
    visitPlus(mathNode: MathPlus): MathNodePriority;
    visitPower(mathNode: MathPower): MathNodePriority;
    visitPredicate(mathNode: MathPredicate): MathNodePriority;
    visitProduct(mathNode: MathProduct): MathNodePriority;
    visitRawText(mathNode: MathRawText): MathNodePriority;
    visitReversedFunction(mathNode: MathReversedFunction): MathNodePriority;
    visitRoot(mathNode: MathRoot): MathNodePriority;
    visitSet(mathNode: MathSet): MathNodePriority;
    visitSquareRoot(mathNode: MathSquareRoot): MathNodePriority;
    visitSubIndex(mathNode: MathSubIndex): MathNodePriority;
    visitSum(mathNode: MathSum): MathNodePriority;
    visitSupremum(mathNode: MathSupremum): MathNodePriority;
    visitSymbol(mathNode: MathSymbol): MathNodePriority;
    visitSystemOfEquations(mathNode: MathSystemOfEquations): MathNodePriority;
    visitTransformation(mathNode: MathTransformation): MathNodePriority;
    visitTrigonometricFunction(mathNode: MathTrigonometricFunction): MathNodePriority;
    visitUnaryMinus(mathNode: MathUnaryMinus): MathNodePriority;
    visitUndefined(mathNode: MathUndefined): MathNodePriority;
    visitUnion(mathNode: MathUnion): MathNodePriority;
    visitVariable(mathNode: MathVariable): MathNodePriority;
    visitVerticalBar(mathNode: MathVerticalBar): MathNodePriority;
}
