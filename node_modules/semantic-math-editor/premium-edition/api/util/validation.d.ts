/**
 * @hidden
 * @packageDocumentation
 */
import { MathAbs, MathAnd, MathAreaIntegral, MathBrackets, MathComma, MathConstant, MathDefiniteIntegral, MathDerivative, MathDeterminant, MathDifferential, MathDivision, MathEmptySet, MathEquality, MathExpressionSet, MathFunction, MathFunctionDifference, MathImplicitMultiply, MathIncludeSet, MathIndefiniteIntegral, MathInfimum, MathIntersection, MathInterval, MathLeibnizDerivative, MathLimit, MathLogarithm, MathMax, MathMin, MathMinus, MathMultiply, MathNaturalLogarithm, MathNode, MathNodeVisitor, MathNumber, MathNumericSet, MathOr, MathParentheses, MathPiecewiseFunction, MathPlaceholder, MathPlus, MathPoint, MathPower, MathPredicate, MathProduct, MathRawText, MathReversedFunction, MathRoot, MathSet, MathSquareRoot, MathStructure, MathSubIndex, MathSum, MathSupremum, MathSymbol, MathSystemOfEquations, MathTransformation, MathTrigonometricFunction, MathUnaryMinus, MathUndefined, MathUnion, MathVariable, MathVerticalBar } from "../model";
import { Class } from "../../../standard-edition/model/utils";
import { Term } from "./term";
import { ErrorSeverity, SemanticError } from "../../../standard-edition/model/errors";
import { AcceptableVisitor } from "./utils";
export declare namespace MathValidationUtils {
    const baseSubject = "a base";
    const comparableOperandsSubject = "comparable operands";
    const denominatorSubject = "a denominator";
    const equationSubject = "an equation";
    const exponentSubject = "an exponent";
    const expressionSubject = "an expression";
    const functionSubject = "a function";
    const indexSubject = "an index";
    const lowerBoundSubject = "a lower bound";
    const numeratorSubject = "a numerator";
    const operandSubject = "an operand";
    const operatorSubject = "an operator";
    const psetSubject = "a set expression";
    const setSubject = "a set";
    const termSubject = "a term";
    const textSubject = "a text value";
    const upperBoundSubject = "an upper bound";
    const variableSubject = "a variable";
    const basePlace = "base";
    const denominatorPlace = "denominator";
    const differentialPlace = "differential";
    const elementPlace = "element";
    const exponentPlace = "exponent";
    const functionPlace = "function";
    const indexPlace = "index";
    const integrandPlace = "integrand";
    const leftBoundPlace = "left bound";
    const lowerBoundPlace = "lower bound";
    const numeratorPlace = "numerator";
    const operandPlace = "operand";
    const operatorPlace = "operator";
    const predicatePlace = "predicate";
    const rightBoundPlace = "right bound";
    const rowPlace = "row";
    const termPlace = "term";
    const textPlace = "text";
    const upperBoundPlace = "upper bound";
    const valuePlace = "value";
    function formatUppercase(input: string): string;
    function wrapErrorStringSimple(parentSubject: string, correctSubject: string, specifiedPlace?: string): string;
    function collectSymbols(mathNode: MathNode): number[];
}
export declare class MathNodeValidationVisitor implements MathNodeVisitor<SemanticError[]>, AcceptableVisitor<SemanticError[]> {
    static readonly instance: MathNodeValidationVisitor;
    protected readonly termVisitor: MathNodeVisitor<Term[]>;
    constructor(termVisitor?: MathNodeVisitor<Term[]>);
    accept(mathNode: MathNode): SemanticError[];
    visitAbs(mathNode: MathAbs): SemanticError[];
    visitAnd(mathNode: MathAnd): SemanticError[];
    visitAreaIntegral(mathNode: MathAreaIntegral): SemanticError[];
    visitBrackets(mathNode: MathBrackets): SemanticError[];
    visitComma(mathNode: MathComma): SemanticError[];
    visitConstant(mathNode: MathConstant): SemanticError[];
    visitDefiniteIntegral(mathNode: MathDefiniteIntegral): SemanticError[];
    visitDerivative(mathNode: MathDerivative): SemanticError[];
    visitDeterminant(mathNode: MathDeterminant): SemanticError[];
    visitDifferential(mathNode: MathDifferential): SemanticError[];
    visitDivision(mathNode: MathDivision): SemanticError[];
    visitEmptySet(mathNode: MathEmptySet): SemanticError[];
    visitEquality(mathNode: MathEquality): SemanticError[];
    visitExpressionSet(mathNode: MathExpressionSet): SemanticError[];
    visitFunction(mathNode: MathFunction): SemanticError[];
    visitFunctionDifference(mathNode: MathFunctionDifference): SemanticError[];
    visitImplicitMultiply(mathNode: MathImplicitMultiply): SemanticError[];
    visitIncludeSet(mathNode: MathIncludeSet): SemanticError[];
    visitIndefiniteIntegral(mathNode: MathIndefiniteIntegral): SemanticError[];
    visitInfimum(mathNode: MathInfimum): SemanticError[];
    visitIntersection(mathNode: MathIntersection): SemanticError[];
    visitInterval(mathNode: MathInterval): SemanticError[];
    visitLeibnizDerivative(mathNode: MathLeibnizDerivative): SemanticError[];
    visitLimit(mathNode: MathLimit): SemanticError[];
    visitLogarithm(mathNode: MathLogarithm): SemanticError[];
    visitMax(mathNode: MathMax): SemanticError[];
    visitMin(mathNode: MathMin): SemanticError[];
    visitMinus(mathNode: MathMinus): SemanticError[];
    visitMultiply(mathNode: MathMultiply): SemanticError[];
    visitNaturalLogarithm(mathNode: MathNaturalLogarithm): SemanticError[];
    visitNumber(mathNode: MathNumber): SemanticError[];
    visitNumericSet(mathNode: MathNumericSet): SemanticError[];
    visitOr(mathNode: MathOr): SemanticError[];
    visitParentheses(mathNode: MathParentheses): SemanticError[];
    visitPiecewiseFunction(mathNode: MathPiecewiseFunction): SemanticError[];
    visitPlaceholder(mathNode: MathPlaceholder): SemanticError[];
    visitPlus(mathNode: MathPlus): SemanticError[];
    visitPoint(mathNode: MathPoint): SemanticError[];
    visitPower(mathNode: MathPower): SemanticError[];
    visitPredicate(mathNode: MathPredicate): SemanticError[];
    visitProduct(mathNode: MathProduct): SemanticError[];
    visitRawText(mathNode: MathRawText): SemanticError[];
    visitReversedFunction(mathNode: MathReversedFunction): SemanticError[];
    visitRoot(mathNode: MathRoot): SemanticError[];
    visitSet(mathNode: MathSet): SemanticError[];
    visitSquareRoot(mathNode: MathSquareRoot): SemanticError[];
    visitSubIndex(mathNode: MathSubIndex): SemanticError[];
    visitSum(mathNode: MathSum): SemanticError[];
    visitSupremum(mathNode: MathSupremum): SemanticError[];
    visitSymbol(mathNode: MathSymbol): SemanticError[];
    visitSystemOfEquations(mathNode: MathSystemOfEquations): SemanticError[];
    visitTransformation(mathNode: MathTransformation): SemanticError[];
    visitTrigonometricFunction(mathNode: MathTrigonometricFunction): SemanticError[];
    visitUnaryMinus(mathNode: MathUnaryMinus): SemanticError[];
    visitUndefined(mathNode: MathUndefined): SemanticError[];
    visitUnion(mathNode: MathUnion): SemanticError[];
    visitVariable(mathNode: MathVariable): SemanticError[];
    visitVerticalBar(mathNode: MathVerticalBar): SemanticError[];
    protected appendErrorToNode(mathNode: MathStructure, error: SemanticError): SemanticError;
    protected createError(errorHolder: MathStructure, child: MathNode, message: string, severity: ErrorSeverity, allowDeeperValidation?: boolean): SemanticError;
    protected getBoundaryTerm(mathNode: MathStructure, getBoundaryOperand: (parent: MathStructure) => MathStructure | null): Term[];
    protected getTerm(mathNode: MathNode): Term[];
    wrap(child: MathStructure, allowedTerms: Class[], defaultErrorMessage: string, nothingErrorMessage: string): SemanticError[];
    protected wrapComma(child: MathStructure, allowedTerms: Class[], defaultErrorMessage: string, nothingErrorMessage: string): SemanticError[];
    protected wrapTransformationOperand(mathNode: MathStructure, allowedTerms: Class[], getBoundaryOperand: (parent: MathStructure) => MathStructure | null): {
        errors: SemanticError[];
        isTransformation: boolean;
        operandTerms: Term[];
    };
}
