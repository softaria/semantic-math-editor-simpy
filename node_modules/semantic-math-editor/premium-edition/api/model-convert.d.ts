/**
 * @hidden
 * @packageDocumentation
 */
import { AnyNode, Terminal } from "../../standard-edition/model/model-base";
import { MathAbs, MathAnd, MathAreaIntegral, MathBrackets, MathComma, MathConstant, MathDefiniteIntegral, MathDerivative, MathDeterminant, MathDifferential, MathDivision, MathEmptySet, MathEquality, MathExpressionSet, MathFunction, MathFunctionDifference, MathImplicitMultiply, MathIncludeSet, MathIndefiniteIntegral, MathInfimum, MathIntersection, MathInterval, MathLeibnizDerivative, MathLimit, MathLimitType, MathLogarithm, MathMax, MathMin, MathMinus, MathMultiply, MathNaturalLogarithm, MathNodeVisitor, MathNumber, MathNumericSet, MathOr, MathParentheses, MathPiecewiseFunction, MathPlaceholder, MathPlus, MathPoint, MathPower, MathPredicate, MathProduct, MathRawText, MathReversedFunction, MathRoot, MathSet, MathSquareRoot, MathStructure, MathSubIndex, MathSum, MathSupremum, MathSymbol, MathSystemOfEquations, MathTransformation, MathTrigonometricFunction, MathTrigonometryType, MathUnaryMinus, MathUndefined, MathUnion, MathVariable, MathVerticalBar } from "./model";
import { TrigName } from "../../standard-edition/model/model-math";
import { SemanticError } from "../../standard-edition/model/errors";
import { MathNodeValidationVisitor } from "./util/validation";
import { SemanticContext } from "../../standard-edition/engine/semantic-context";
export declare function convertTreeToMathTree(tree: AnyNode, semanticContext: SemanticContext, semanticValidator?: MathNodeValidationVisitor, leftCursor?: Terminal, rightCursor?: Terminal): [MathStructure, SemanticError[]];
export declare function setCursor(arg: MathSymbol, isLeft: boolean): MathSymbol;
export declare function getCursor(arg: MathSymbol, isLeft: boolean): boolean;
export declare function removeCursor(arg: MathSymbol): boolean;
export declare function setCell(arg: MathStructure, borderVisible: boolean, avoidParenthesesWrap: boolean): MathStructure;
export declare function getCell(arg: MathStructure): {
    borderVisible: boolean;
    avoidParenthesesWrap: boolean;
};
export declare function removeCell(arg: MathStructure): boolean;
export declare function convertMathTrigonometryToTrigonometry(mathTrig: MathTrigonometryType): TrigName;
export declare class MathNodeToAnyNodeConverter implements MathNodeVisitor<AnyNode> {
    semanticContext: {
        isPoint?: boolean;
    };
    leftCursor: Terminal;
    rightCursor: Terminal;
    cells: {
        node: AnyNode;
        borderVisible: boolean;
        avoidParenthesesWrap: boolean;
    }[];
    handleMathLimitType(limitType: MathLimitType, signIndex: MathSymbol, sign: MathSymbol, constLimit: AnyNode): AnyNode;
    visitAbs(mathNode: MathAbs): AnyNode;
    visitAnd(mathNode: MathAnd): AnyNode;
    visitAreaIntegral(mathNode: MathAreaIntegral): AnyNode;
    visitBrackets(mathNode: MathBrackets): AnyNode;
    visitComma(mathNode: MathComma): AnyNode;
    visitConstant(mathNode: MathConstant): AnyNode;
    visitDefiniteIntegral(mathNode: MathDefiniteIntegral): AnyNode;
    visitDerivative(mathNode: MathDerivative): AnyNode;
    visitDeterminant(mathNode: MathDeterminant): AnyNode;
    visitDifferential(mathNode: MathDifferential): AnyNode;
    visitDivision(mathNode: MathDivision): AnyNode;
    visitEmptySet(mathNode: MathEmptySet): AnyNode;
    visitEquality(mathNode: MathEquality): AnyNode;
    visitExpressionSet(mathNode: MathExpressionSet): AnyNode;
    visitFunction(mathNode: MathFunction): AnyNode;
    visitFunctionDifference(mathNode: MathFunctionDifference): AnyNode;
    visitImplicitMultiply(mathNode: MathImplicitMultiply): AnyNode;
    visitIncludeSet(mathNode: MathIncludeSet): AnyNode;
    visitIndefiniteIntegral(mathNode: MathIndefiniteIntegral): AnyNode;
    visitInfimum(mathNode: MathInfimum): AnyNode;
    visitIntersection(mathNode: MathIntersection): AnyNode;
    visitInterval(mathNode: MathInterval): AnyNode;
    visitLeibnizDerivative(mathNode: MathLeibnizDerivative): AnyNode;
    visitLimit(mathNode: MathLimit): AnyNode;
    visitLogarithm(mathNode: MathLogarithm): AnyNode;
    visitMax(mathNode: MathMax): AnyNode;
    visitMin(mathNode: MathMin): AnyNode;
    visitMinus(mathNode: MathMinus): AnyNode;
    visitMultiply(mathNode: MathMultiply): AnyNode;
    visitNaturalLogarithm(mathNode: MathNaturalLogarithm): AnyNode;
    visitNumber(mathNode: MathNumber): AnyNode;
    visitNumericSet(mathNode: MathNumericSet): AnyNode;
    visitOr(mathNode: MathOr): AnyNode;
    visitParentheses(mathNode: MathParentheses): AnyNode;
    visitPiecewiseFunction(mathNode: MathPiecewiseFunction): AnyNode;
    visitPlaceholder(mathNode: MathPlaceholder): AnyNode;
    visitPlus(mathNode: MathPlus): AnyNode;
    visitPoint(mathNode: MathPoint): AnyNode;
    visitPower(mathNode: MathPower): AnyNode;
    visitPredicate(mathNode: MathPredicate): AnyNode;
    visitProduct(mathNode: MathProduct): AnyNode;
    visitRawText(mathNode: MathRawText): AnyNode;
    visitReversedFunction(mathNode: MathReversedFunction): AnyNode;
    visitRoot(mathNode: MathRoot): AnyNode;
    visitSet(mathNode: MathSet): AnyNode;
    visitSquareRoot(mathNode: MathSquareRoot): AnyNode;
    visitSubIndex(mathNode: MathSubIndex): AnyNode;
    visitSum(mathNode: MathSum): AnyNode;
    visitSupremum(mathNode: MathSupremum): AnyNode;
    visitSymbol(mathNode: MathSymbol): AnyNode;
    visitSystemOfEquations(mathNode: MathSystemOfEquations): AnyNode;
    visitTransformation(mathNode: MathTransformation): AnyNode;
    visitTrigonometricFunction(mathNode: MathTrigonometricFunction): AnyNode;
    visitUnaryMinus(mathNode: MathUnaryMinus): AnyNode;
    visitUndefined(mathNode: MathUndefined): AnyNode;
    visitUnion(mathNode: MathUnion): AnyNode;
    visitVariable(mathNode: MathVariable): AnyNode;
    visitVerticalBar(mathNode: MathVerticalBar): AnyNode;
    private convertMathBracketstoBrackets;
    private convertToString;
    private convertToValue;
    private handleNode;
    private handleTerminal;
    private validatePointAndInterval;
    private wrapWithComma;
    private wrapWithHiddenMultiply;
}
