/**
 * @hidden
 * @packageDocumentation
 */
import { AbstractCellNode, NonTerminalVisitor, NothingNode, PrivateTerminal, RawNode, RootNode, Terminal, TerminalVisitor } from "../model/model-base";
import { AbstractBracketsNode, BinaryOperationNode, ConstantNode, DeterminantNode, DivideNode, EmptysetVariableNode, FuncNode, GreekVariableNode, IntegralNode, LatinVariableNode, LimNode, LogNode, MathRootNode, NumsetVariableNode, OperatorNameNode, PiecewiseFunctionNode, PredicateNode, PrimeNode, ProdOrSumNode, SubIndexNode, SupIndexNode, SupSubIndexNode, SystemOfEquationsNode, UnaryMinusNode, UndefinedNode, ValueNode } from "../model/model-math";
import { LevelLocation } from "../structure/visual-levels";
/**
 * For usual terminals, reuses the general logic of AnyNodeSpeaker.
 * Used to pronounce any kind of terminal around the cursor. Specify additional info for private terminals:
 * @lookAtLeft: if node has two private terminals on one level (currently the only case of multiple terminals),
 * determines which one to analyze.
 * @cursorIsInside: for nodes with inner visual levels, determines if the cursor is inside. It affects the decision which
 * private terminal should be spoken.
 */
export declare class CursorTerminalSpeaker implements TerminalVisitor<string> {
    private readonly endOfInnerVisualLevel;
    private readonly lookAtLeft;
    private readonly location;
    private readonly optionalOtherTerminal;
    constructor(endOfInnerVisualLevel?: boolean, lookAtLeft?: boolean, location?: LevelLocation, optionalTerminal?: Terminal);
    visitConstant(node: ConstantNode): string;
    visitEmptyset(node: EmptysetVariableNode): string;
    visitGreek(node: GreekVariableNode): string;
    visitLatin(node: LatinVariableNode): string;
    visitNothing(node: NothingNode): string;
    visitNumset(node: NumsetVariableNode): string;
    visitOperatorName(node: OperatorNameNode): string;
    visitPrivateTerminal(node: PrivateTerminal): string;
    visitRaw(node: RawNode): string;
    visitUndefined(node: UndefinedNode): string;
    visitValue(node: ValueNode): string;
}
/**
 * Uses the parent non-terminal and some additional cursor info to specify what to print
 * this one has a special, shortened pronunciations
 */
export declare class PrivateTerminalSpeaker implements NonTerminalVisitor<string> {
    private readonly terminal;
    private readonly otherTerminal;
    private readonly endOfInnerVisualLevel;
    private readonly lookAtLeft;
    private readonly location;
    constructor(specifiedTerminal: PrivateTerminal, otherTerminal: Terminal, cursorIsInside: boolean, lookAtLeft: boolean, location?: LevelLocation);
    visitAbstractBrackets(node: AbstractBracketsNode): string;
    visitBinaryOperation(node: BinaryOperationNode): string;
    visitCell(node: AbstractCellNode): string;
    visitDivide(node: DivideNode): string;
    visitFunction(node: FuncNode): string;
    visitInt(node: IntegralNode): string;
    visitLim(node: LimNode): string;
    visitLog(node: LogNode): string;
    visitMathRoot(node: MathRootNode): string;
    visitPredicate(node: PredicateNode): string;
    visitPrime(node: PrimeNode): string;
    visitProdOrSum(node: ProdOrSumNode): string;
    visitRoot(node: RootNode): string;
    visitSub(node: SubIndexNode): string;
    visitSup(node: SupIndexNode): string;
    visitSupSub(node: SupSubIndexNode): string;
    visitUnaryMinus(node: UnaryMinusNode): string;
    visitDeterminant(node: DeterminantNode): string;
    visitSystemOfEquations(node: SystemOfEquationsNode): string;
    visitPiecewiseFunction(node: PiecewiseFunctionNode): string;
    /**
     * Sometimes we have a one Private Terminal for two visual symbols as "right" and "left" one
     * with inner visual level.
     * Here we choose which one to print: left one or right one
     */
    private selectLeftOrRightPTString;
}
