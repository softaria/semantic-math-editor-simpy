/**
 * @hidden
 * @packageDocumentation
 */
import { AbsNode, AbstractBracketsNode, AndNode, ApproxEqualsNode, BinaryOperationNode, BinaryOperationNodeVisitor, BracketsNodeVisitor, ClosedIntervalNode, CommaNode, ConstantNode, DeterminantNode, DifferentialNode, DivideNode, EmptysetVariableNode, EqualsNode, FuncNode, GreaterOrEqualsNode, GreaterThanNode, GreekVariableNode, IncludeSetNode, InfSupNameNode, IntegralNode, IntersectionSetNode, LatinVariableNode, LeftClosedIntervalNode, LessOrEqualsNode, LessThanNode, LimNode, LnNode, LogNode, MathRootNode, MinMaxNode, MinusNode, MultiplyNode, NotEqualsNode, NumsetVariableNode, OpenBracketsNode, OperatorNameNode, OperatorNameVisitor, OrNode, PiecewiseFunctionNode, PlusNode, PredicateNode, PrimeNode, ProdOrSumNode, RightClosedIntervalNode, SetNode, SubIndexNode, SupIndexNode, SupSubIndexNode, SystemOfEquationsNode, TrigNameNode, UnaryMinusNode, UndefinedNode, UnionSetNode, ValueNode, VerticalBarNode } from "../model/model-math";
import { AbstractCellNode, AnyNode, AnyNodeVisitor, CellVisitor, NestedCellNode, NonTerminal, NonTerminalVisitor, NothingNode, PlainCellNode, PrivateTerminal, RawNode, RootNode, Terminal, TerminalVisitor } from "../model/model-base";
import { VisualGraph, VisualLevel } from "../structure/visual-levels";
import { CursorPosition } from "../model/cursor-position";
import { Selection } from '../engine/selection/selection';
export declare class VisualLevelCollector implements NonTerminalVisitor<AnyNode> {
    private readonly pt;
    constructor(pt: PrivateTerminal);
    visitRoot(node: RootNode): AnyNode;
    visitDivide(node: DivideNode): AnyNode;
    visitFunction(node: FuncNode): AnyNode;
    visitInt(node: IntegralNode): AnyNode;
    visitLim(node: LimNode): AnyNode;
    visitProdOrSum(node: ProdOrSumNode): AnyNode;
    visitLog(node: LogNode): AnyNode;
    visitMathRoot(node: MathRootNode): AnyNode;
    visitCell(node: AbstractCellNode): AnyNode;
    visitAbstractBrackets(node: AbstractBracketsNode): AnyNode;
    visitSup(node: SupIndexNode): AnyNode;
    visitSub(node: SubIndexNode): AnyNode;
    visitSupSub(node: SupSubIndexNode): AnyNode;
    visitPrime(node: PrimeNode): AnyNode;
    visitUnaryMinus(node: UnaryMinusNode): AnyNode;
    visitBinaryOperation(node: BinaryOperationNode): AnyNode;
    visitPredicate(node: PredicateNode): AnyNode;
    visitDeterminant(node: DeterminantNode): AnyNode;
    visitSystemOfEquations(node: SystemOfEquationsNode): AnyNode;
    visitPiecewiseFunction(node: PiecewiseFunctionNode): AnyNode;
}
export declare function speakCurrentVisualLevel(visualGraph: VisualGraph, cursorPosition: CursorPosition, selection: Selection): string;
export declare function speakVisualLevel(visualLevel: VisualLevel, visualGraph?: VisualGraph, cursorPosition?: CursorPosition, selection?: Selection): string;
/**
 * For non-terminals, prints ONLY it's inner children. No open-left and open-right chaining.
 * To print the whole visual level, use the AnyNodeOpenLeftRightSpeaker
 */
export declare class AnyNodeSpeaker implements AnyNodeVisitor<string>, NonTerminalVisitor<string>, TerminalVisitor<string>, OperatorNameVisitor<string>, CellVisitor<string> {
    static readonly instance: AnyNodeSpeaker;
    protected exclusiveChildrenSpeak: AnyNode[];
    constructor(exclusiveChildrenSpeak?: AnyNode[]);
    visitTerminal(node: Terminal): string;
    visitNonTerminal(node: NonTerminal): string;
    visitRaw(node: RawNode): string;
    visitConstant(node: ConstantNode): string;
    visitUndefined(node: UndefinedNode): string;
    visitDivide(node: DivideNode): string;
    visitUnaryMinus(node: UnaryMinusNode): string;
    visitFunction(node: FuncNode): string;
    visitLim(node: LimNode): string;
    visitProdOrSum(node: ProdOrSumNode): string;
    visitLog(node: LogNode): string;
    visitValue(node: ValueNode): string;
    visitEmptyset(node: EmptysetVariableNode): string;
    visitGreek(node: GreekVariableNode): string;
    visitLatin(node: LatinVariableNode): string;
    visitNumset(node: NumsetVariableNode): string;
    visitTrigName(node: TrigNameNode): string;
    visitLn(node: LnNode): string;
    visitInfSup(node: InfSupNameNode): string;
    visitRoot(node: RootNode): string;
    visitCell(node: AbstractCellNode): string;
    visitPlain(node: PlainCellNode): string;
    visitNested(node: NestedCellNode): string;
    visitAbstractBrackets(node: AbstractBracketsNode): string;
    visitMathRoot(node: MathRootNode): string;
    visitSup(node: SupIndexNode): string;
    visitSub(node: SubIndexNode): string;
    visitSupSub(node: SupSubIndexNode): string;
    visitPrime(node: PrimeNode): string;
    visitNothing(node: NothingNode): string;
    visitDiff(node: DifferentialNode): string;
    visitInt(node: IntegralNode): string;
    visitPrivateTerminal(node: PrivateTerminal): string;
    visitBinaryOperation(node: BinaryOperationNode): string;
    visitOperatorName(node: OperatorNameNode): string;
    visitPredicate(node: PredicateNode): string;
    visitDeterminant(node: DeterminantNode): string;
    visitSystemOfEquations(node: SystemOfEquationsNode): string;
    visitPiecewiseFunction(node: PiecewiseFunctionNode): string;
}
/**
 * Suitable to speak the whole visual level as it chains through the open constructions.
 */
export declare class AnyNodeOpenLeftRightSpeaker implements AnyNodeVisitor<string>, NonTerminalVisitor<string>, TerminalVisitor<string>, OperatorNameVisitor<string>, CellVisitor<string> {
    static readonly instance: AnyNodeOpenLeftRightSpeaker;
    protected privateTerminal: any;
    protected cursorPosition: CursorPosition;
    protected selection: Selection;
    protected visualGraph: VisualGraph;
    constructor(privateTerminal?: Terminal, cursorPosition?: CursorPosition, selection?: Selection, vg?: VisualGraph);
    private wrapTerminal;
    private wrap;
    visitTerminal(node: Terminal): string;
    visitNonTerminal(node: NonTerminal): string;
    private getDefault;
    visitRaw(node: RawNode): string;
    visitConstant(node: ConstantNode): string;
    visitUndefined(node: UndefinedNode): string;
    visitDivide(node: DivideNode): string;
    visitUnaryMinus(node: UnaryMinusNode): string;
    visitFunction(node: FuncNode): string;
    visitLim(node: LimNode): string;
    visitProdOrSum(node: ProdOrSumNode): string;
    visitLog(node: LogNode): string;
    visitValue(node: ValueNode): string;
    visitEmptyset(node: EmptysetVariableNode): string;
    visitGreek(node: GreekVariableNode): string;
    visitLatin(node: LatinVariableNode): string;
    visitNumset(node: NumsetVariableNode): string;
    visitTrigName(node: TrigNameNode): string;
    visitLn(node: LnNode): string;
    visitInfSup(node: InfSupNameNode): string;
    visitRoot(node: RootNode): string;
    visitCell(node: AbstractCellNode): string;
    visitPlain(node: PlainCellNode): string;
    visitNested(node: NestedCellNode): string;
    visitAbstractBrackets(node: AbstractBracketsNode): string;
    visitMathRoot(node: MathRootNode): string;
    visitSup(node: SupIndexNode): string;
    visitSub(node: SubIndexNode): string;
    visitSupSub(node: SupSubIndexNode): string;
    visitPrime(node: PrimeNode): string;
    visitNothing(node: NothingNode): string;
    visitDiff(node: DifferentialNode): string;
    visitInt(node: IntegralNode): string;
    visitPrivateTerminal(node: PrivateTerminal): string;
    visitBinaryOperation(node: BinaryOperationNode): string;
    visitOperatorName(node: OperatorNameNode): string;
    visitPredicate(node: PredicateNode): string;
    visitDeterminant(node: DeterminantNode): string;
    visitSystemOfEquations(node: SystemOfEquationsNode): string;
    visitPiecewiseFunction(node: PiecewiseFunctionNode): string;
}
export declare class BinaryOperationAriaSpeakName implements BinaryOperationNodeVisitor<string> {
    static readonly instance: BinaryOperationAriaSpeakName;
    visitEquals(node: EqualsNode): string;
    visitApproxEquals(node: ApproxEqualsNode): string;
    visitGreaterOrEquals(node: GreaterOrEqualsNode): string;
    visitGreaterThan(node: GreaterThanNode): string;
    visitLessOrEquals(node: LessOrEqualsNode): string;
    visitLessThan(node: LessThanNode): string;
    visitMinus(node: MinusNode): string;
    visitMultiply(node: MultiplyNode): string;
    visitNotEquals(node: NotEqualsNode): string;
    visitPlus(node: PlusNode): string;
    visitComma(node: CommaNode): string;
    visitIntersection(node: IntersectionSetNode): string;
    visitUnion(node: UnionSetNode): string;
    visitAnd(node: AndNode): string;
    visitOr(node: OrNode): string;
    visitInclude(node: IncludeSetNode): string;
    visitVerticalBar(node: VerticalBarNode): string;
}
export declare class BinaryOperationSpeakName implements BinaryOperationNodeVisitor<string> {
    static readonly instance: BinaryOperationSpeakName;
    visitEquals(node: EqualsNode): string;
    visitApproxEquals(node: ApproxEqualsNode): string;
    visitGreaterOrEquals(node: GreaterOrEqualsNode): string;
    visitGreaterThan(node: GreaterThanNode): string;
    visitLessOrEquals(node: LessOrEqualsNode): string;
    visitLessThan(node: LessThanNode): string;
    visitMinus(node: MinusNode): string;
    visitMultiply(node: MultiplyNode): string;
    visitNotEquals(node: NotEqualsNode): string;
    visitPlus(node: PlusNode): string;
    visitComma(node: CommaNode): string;
    visitIntersection(node: IntersectionSetNode): string;
    visitUnion(node: UnionSetNode): string;
    visitAnd(node: AndNode): string;
    visitOr(node: OrNode): string;
    visitInclude(node: IncludeSetNode): string;
    visitVerticalBar(node: VerticalBarNode): string;
}
export declare class BracketSymbolAriaSpeak implements BracketsNodeVisitor<{
    left: string;
    right: string;
}> {
    static instance: BracketSymbolAriaSpeak;
    visitClosed(node: ClosedIntervalNode): {
        left: string;
        right: string;
    };
    visitLeftClosed(node: LeftClosedIntervalNode): {
        left: string;
        right: string;
    };
    visitOpen(node: OpenBracketsNode): {
        left: string;
        right: string;
    };
    visitRightClosed(node: RightClosedIntervalNode): {
        left: string;
        right: string;
    };
    visitAbs(node: AbsNode): {
        left: string;
        right: string;
    };
    visitMinMax(node: MinMaxNode): {
        left: string;
        right: string;
    };
    visitSet(node: SetNode): {
        left: string;
        right: string;
    };
}
