/**
 * @hidden
 * @packageDocumentation
 */
import { AnyNode, RootNode } from "../model/model-base";
import { AbstractBracketsNode, OpenBracketsNode, VariableNode } from "../model/model-math";
import { UndoRedoEditor } from "../editor/undo-redo-editor";
import { Replacement } from "../engine/hints";
import { SemanticContext } from "../engine/semantic-context";
export declare class SelectionAdviceReplacement {
    replacements: Replacement[];
    constructor();
    private static createSelectionReplacements;
    toString(): string;
}
export declare class NonTypableAdviceReplacement {
    replacements: Replacement[];
    constructor();
    private static createNonTypableReplacements;
    toString(): string;
}
export interface IAdvice {
    accept<T>(visitor: IAdviceVisitor<T>): T;
}
export interface IAdviceVisitor<T> {
    visitContext(adv: AbstractContextAdvice): T;
    visitReplacement(adv: AbstractReplacementAdvice): T;
}
export interface IContextAdviceVisitor<T> extends IAdviceVisitor<T> {
    visitFunctionVariable(adv: FunctionVariableContextAdvice): T;
    visitPoint(adv: PointContextAdvice): T;
}
export interface IReplacementAdviceVisitor<T> extends IAdviceVisitor<T> {
    visitInsertVariable(adv: InsertVariableAdvice): T;
    visitBracketConvertation(adv: BracketConvertationAdvice): T;
    visitSequenceReplacement(adv: SequenceReplacementAdvice): T;
    visitInsertion(adv: InsertionAdvice): T;
    visitSelection(adv: SelectionReplacementAdvice): T;
    visitSpaceContainerModify(adv: SpaceContainerModifierAdvice): T;
    visitImathConvertation(adv: ImathConvertationAdvice): T;
}
export declare abstract class AbstractContextAdvice implements IAdvice {
    accept<T>(visitor: IAdviceVisitor<T>): T;
    abstract acceptContext<T>(visitor: IContextAdviceVisitor<T>): T;
}
export declare class PointContextAdvice extends AbstractContextAdvice {
    readonly editor: UndoRedoEditor;
    readonly isPoint: boolean;
    readonly brackets: OpenBracketsNode;
    constructor(editor: UndoRedoEditor, brackets: OpenBracketsNode, isPoint: boolean);
    acceptContext<T>(visitor: IContextAdviceVisitor<T>): T;
}
export declare class FunctionVariableContextAdvice extends AbstractContextAdvice {
    readonly editor: UndoRedoEditor;
    readonly plainText: string;
    readonly isFunctionVariable: boolean;
    private readonly operatorNode;
    readonly expression: RootNode;
    constructor(editor: UndoRedoEditor, operatorNode: VariableNode, root: RootNode, isFunctionVariable: boolean);
    acceptContext<T>(visitor: IContextAdviceVisitor<T>): T;
}
export declare abstract class AbstractReplacementAdvice implements IAdvice {
    readonly repl: Replacement;
    readonly editor: UndoRedoEditor;
    readonly placePointerAfterApply: boolean;
    readonly nodes: AnyNode[];
    readonly semanticContextOnApply: ((semanticContext: SemanticContext) => void)[];
    constructor(nodes: AnyNode[], repl: Replacement, editor: UndoRedoEditor, placePointer: boolean, semanticContextOnApply?: (semanticContext: SemanticContext) => void);
    accept<T>(visitor: IAdviceVisitor<T>): T;
    abstract acceptReplacement<T>(visitor: IReplacementAdviceVisitor<T>): T;
}
export declare enum SpaceContainerModifyMode {
    addRowAbove = 0,
    addRowBelow = 1,
    removeRow = 2,
    addColumnLeft = 3,
    addColumnRight = 4,
    removeColumn = 5
}
export declare class SpaceContainerModifierAdvice extends AbstractReplacementAdvice {
    readonly mode: SpaceContainerModifyMode;
    readonly isLeft: boolean;
    constructor(nodeToReplace: AnyNode[], repl: Replacement, editor: UndoRedoEditor, mode: SpaceContainerModifyMode);
    acceptReplacement<T>(visitor: IReplacementAdviceVisitor<T>): T;
}
export declare class InsertVariableAdvice extends AbstractReplacementAdvice {
    readonly expression: RootNode;
    private readonly variable;
    constructor(repl: Replacement, variable: VariableNode, expression: RootNode, editor: UndoRedoEditor);
    get plainText(): string;
    acceptReplacement<T>(visitor: IReplacementAdviceVisitor<T>): T;
}
export declare abstract class CompoundReplacementAdvice extends AbstractReplacementAdvice {
    readonly label: string;
    readonly plainText: string;
    readonly expression: RootNode;
    readonly optionalPriority?: number;
    protected constructor(label: string, replacementTextSymbols: string, expression: RootNode, nodes: AnyNode[], repl: Replacement, editor: UndoRedoEditor, placePointer: boolean, explicitPriority?: number, semanticContextOnApply?: (semanticContext: SemanticContext) => void);
    abstract acceptReplacement<T>(visitor: IReplacementAdviceVisitor<T>): T;
}
export declare class NullObjectReplacementAdvice extends AbstractReplacementAdvice {
    constructor(nodes: AnyNode[], repl: Replacement, editor: UndoRedoEditor, placePointer: boolean, semanticContextOnApply?: (semanticContext: SemanticContext) => void);
    acceptReplacement<T>(visitor: IReplacementAdviceVisitor<T>): T;
}
export declare class SequenceReplacementAdvice extends CompoundReplacementAdvice {
    readonly tailText: string;
    constructor(label: string, plainText: string, tailText: string, expression: RootNode, repl: Replacement, editor: UndoRedoEditor, placePointer: boolean, nodes: AnyNode[], explicitPriority?: number);
    acceptReplacement<T>(visitor: IReplacementAdviceVisitor<T>): T;
}
export declare class ImathConvertationAdvice extends AbstractReplacementAdvice {
    readonly iToImath: boolean;
    readonly expression: RootNode;
    constructor(expression: RootNode, repl: Replacement, editor: UndoRedoEditor, nodes: AnyNode[], iToImath: boolean);
    acceptReplacement<T>(visitor: IReplacementAdviceVisitor<T>): T;
}
export declare class BracketConvertationAdvice extends CompoundReplacementAdvice {
    readonly modifiedNode: AbstractBracketsNode;
    readonly placeCursorInside: boolean;
    constructor(expression: RootNode, modifiedNode: AbstractBracketsNode, placeCursorInside: boolean, repl: Replacement, label: string, plainText: string, editor: UndoRedoEditor, placePointer: boolean, nodes: AnyNode[], explicitPriorityAddition: number, semanticContextOnApply?: (semanticContext: SemanticContext) => void);
    acceptReplacement<T>(visitor: IReplacementAdviceVisitor<T>): T;
}
export declare class InsertionAdvice extends CompoundReplacementAdvice {
    constructor(label: string, plainText: string, expression: RootNode, repl: Replacement, editor: UndoRedoEditor, placePointer?: boolean, explicitPriority?: number);
    acceptReplacement<T>(visitor: IReplacementAdviceVisitor<T>): T;
}
export declare class SelectionReplacementAdvice extends CompoundReplacementAdvice {
    readonly wrappedExpression: RootNode;
    constructor(label: string, plainText: string, expression: RootNode, wrappedExpression: RootNode, nodes: AnyNode[], repl: Replacement, editor: UndoRedoEditor, placePointer?: boolean, explicitPriority?: number);
    acceptReplacement<T>(visitor: IReplacementAdviceVisitor<T>): T;
}
