/**
 * @hidden
 * @packageDocumentation
 */
import { HasMainChild, HasOpenLeftChild, HasOpenRightChild } from "./open-children";
import { AnyNode, AtomNode, BasicTerminal, ExpressionNode, INonTerminal, NonTerminal, NonTerminalVisitor, PostInsertHook, PrivateTerminal, TerminalVisitor } from "./model-base";
import { Point } from "./utils";
declare module './model-base' {
    interface NonTerminalVisitor<T> {
        visitBinaryOperation(node: BinaryOperationNode): T;
        visitUnaryMinus(node: UnaryMinusNode): T;
        visitFunction(node: FuncNode): T;
        visitLim(node: LimNode): T;
        visitAbstractBrackets(node: AbstractBracketsNode): T;
        visitMathRoot(node: MathRootNode): T;
        visitSup(node: SupIndexNode): T;
        visitSub(node: SubIndexNode): T;
        visitSupSub(node: SupSubIndexNode): T;
        visitPrime(node: PrimeNode): T;
        visitDivide(node: DivideNode): T;
        visitInt(node: IntegralNode): T;
        visitLog(node: LogNode): T;
        visitProdOrSum(node: ProdOrSumNode): T;
        visitPredicate(node: PredicateNode): T;
        visitDeterminant(node: DeterminantNode): T;
        visitSystemOfEquations(node: SystemOfEquationsNode): T;
        visitPiecewiseFunction(node: PiecewiseFunctionNode): T;
    }
    interface TerminalVisitor<T> {
        visitOperatorName(node: OperatorNameNode): T;
        visitConstant(node: ConstantNode): T;
        visitUndefined(node: UndefinedNode): T;
        visitLatin(node: LatinVariableNode): T;
        visitGreek(node: GreekVariableNode): T;
        visitNumset(node: NumsetVariableNode): T;
        visitEmptyset(node: EmptysetVariableNode): T;
        visitValue(node: ValueNode): T;
    }
    interface NonTerminal {
        replaceChild(existingChild: AnyNode, newChild: AnyNode): boolean;
    }
}
export interface BinaryOperationNodeVisitor<T> {
    visitEquals(node: EqualsNode): T;
    visitNotEquals(node: NotEqualsNode): T;
    visitApproxEquals(node: ApproxEqualsNode): T;
    visitLessThan(node: LessThanNode): T;
    visitGreaterThan(node: GreaterThanNode): T;
    visitLessOrEquals(node: LessOrEqualsNode): T;
    visitGreaterOrEquals(node: GreaterOrEqualsNode): T;
    visitPlus(node: PlusNode): T;
    visitMinus(node: MinusNode): T;
    visitMultiply(node: MultiplyNode): T;
    visitComma(node: CommaNode): T;
    visitUnion(node: UnionSetNode): T;
    visitIntersection(node: IntersectionSetNode): T;
    visitInclude(node: IncludeSetNode): T;
    visitAnd(node: AndNode): T;
    visitOr(node: OrNode): T;
    visitVerticalBar(node: VerticalBarNode): T;
}
export declare enum OperationPriority {
    transformation = 0,
    verticalBar = 1,
    comma = 2,
    isStatement = 3,
    orOperation = 4,
    andOperation = 5,
    equalityOperation = 6,
    include = 7,
    setOperation = 8,
    plusAndMinus = 9,
    unaryMinus = 10,
    multiply = 11,
    rightOperand = 12,
    divide = 13,
    differentialOperand = 14,
    leftOperand = 15,
    join = 16
}
export declare abstract class BinaryOperationNode extends NonTerminal implements HasOpenLeftChild, HasOpenRightChild, ExpressionNode {
    readonly op: PrivateTerminal;
    protected constructor(parent: INonTerminal, stringRepresentation: string);
    left: AnyNode;
    right: AnyNode;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    abstract acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getLeftChild(): AnyNode;
    getRightChild(): AnyNode;
    isOpenLeft(leftNode: AnyNode): boolean;
    isOpenRight(rightNode: AnyNode): boolean;
    abstract getLeftPriority(rotateTarget?: AnyNode): number;
    abstract getRightPriority(rotateTarget?: AnyNode): number;
}
export declare abstract class BinaryEqualityNode extends BinaryOperationNode {
    protected constructor(parent: INonTerminal, stringRepresentation: string);
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
}
export declare enum EqualityType {
    equals = "=",
    notEquals = "<>",
    approxEquals = "~",
    lessThan = "<",
    greaterThan = ">",
    greaterOrEquals = ">=",
    lessOrEquals = "<="
}
export declare namespace EqualityType {
    function parse(str: string): EqualityType;
}
export declare class EqualsNode extends BinaryEqualityNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class TransformationNode extends EqualsNode {
    constructor(parent: INonTerminal);
    getEmptyClone(): INonTerminal;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
}
export declare class NotEqualsNode extends BinaryEqualityNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class ApproxEqualsNode extends BinaryEqualityNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class LessThanNode extends BinaryEqualityNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class GreaterThanNode extends BinaryEqualityNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class LessOrEqualsNode extends BinaryEqualityNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class GreaterOrEqualsNode extends BinaryEqualityNode {
    constructor(parent: INonTerminal);
    getEmptyClone(): INonTerminal;
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
}
export declare class VerticalBarNode extends BinaryOperationNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
}
export declare class PlusNode extends BinaryOperationNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export declare class MinusNode extends BinaryOperationNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export declare class MultiplyNode extends BinaryOperationNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export declare class HiddenMultiplyNode extends MultiplyNode {
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    private isValuePriority;
}
export declare class CommaNode extends BinaryOperationNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export declare class UnionSetNode extends BinaryOperationNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export declare class AndNode extends BinaryOperationNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export declare class OrNode extends BinaryOperationNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export declare class IntersectionSetNode extends BinaryOperationNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export declare class IncludeSetNode extends BinaryOperationNode {
    constructor(parent: INonTerminal);
    acceptBinaryOperation<T>(visitor: BinaryOperationNodeVisitor<T>): T;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export interface BracketsNodeVisitor<T> {
    visitAbs(node: AbsNode): T;
    visitMinMax(node: MinMaxNode): T;
    visitOpen(node: OpenBracketsNode): T;
    visitClosed(node: ClosedIntervalNode): T;
    visitLeftClosed(node: LeftClosedIntervalNode): T;
    visitRightClosed(node: RightClosedIntervalNode): T;
    visitSet(node: SetNode): T;
}
export declare abstract class AbstractBracketsNode extends NonTerminal implements ExpressionNode, HasMainChild {
    readonly par: PrivateTerminal;
    child: AnyNode;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    abstract acceptAbstractBrackets<T>(visitor: BracketsNodeVisitor<T>): T;
    getMainChild(): AnyNode;
}
export declare class SetNode extends AbstractBracketsNode {
    acceptAbstractBrackets<T>(visitor: BracketsNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class AbsNode extends AbstractBracketsNode {
    acceptAbstractBrackets<T>(visitor: BracketsNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class MinMaxNode extends AbstractBracketsNode {
    readonly isMinNode: boolean;
    constructor(parent: INonTerminal, isMinNode: boolean);
    acceptAbstractBrackets<T>(visitor: BracketsNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare abstract class BracketsNode extends AbstractBracketsNode {
}
export declare class OpenBracketsNode extends BracketsNode {
    acceptAbstractBrackets<T>(visitor: BracketsNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class ClosedIntervalNode extends BracketsNode {
    acceptAbstractBrackets<T>(visitor: BracketsNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class LeftClosedIntervalNode extends BracketsNode {
    acceptAbstractBrackets<T>(visitor: BracketsNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class RightClosedIntervalNode extends BracketsNode {
    acceptAbstractBrackets<T>(visitor: BracketsNodeVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class UnaryMinusNode extends NonTerminal implements HasOpenRightChild, ExpressionNode {
    readonly op: PrivateTerminal;
    child: AnyNode;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getRightChild(): AnyNode;
    isOpenRight(rightNode: AnyNode): boolean;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export declare enum TrigName {
    sin = "sin",
    cos = "cos",
    tan = "tan",
    csc = "csc",
    sec = "sec",
    cot = "cot",
    arcsin = "arcsin",
    arccos = "arccos",
    arctan = "arctan",
    arccsc = "arccsc",
    arcsec = "arcsec",
    arccot = "arccot",
    sinh = "sinh",
    cosh = "cosh",
    tanh = "tanh",
    arcsinh = "arcsinh",
    arccosh = "arccosh",
    arctanh = "arctanh"
}
export declare class MathRootNode extends NonTerminal implements ExpressionNode, HasMainChild {
    readonly root: PrivateTerminal;
    child: AnyNode;
    degree: AnyNode;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getMainChild(): AnyNode;
    getEmptyClone(): INonTerminal;
}
export declare class SupIndexNode extends NonTerminal implements ExpressionNode, HasOpenLeftChild, HasMainChild {
    readonly rightBoundary: PrivateTerminal;
    child: AnyNode;
    index: AnyNode;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getLeftChild(): AnyNode;
    isOpenLeft(leftNode: AnyNode): boolean;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getMainChild(): AnyNode;
    getEmptyClone(): INonTerminal;
}
export declare class SubIndexNode extends NonTerminal implements ExpressionNode, HasOpenLeftChild, HasMainChild {
    readonly rightBoundary: PrivateTerminal;
    child: AnyNode;
    index: AnyNode;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getLeftChild(): AnyNode;
    isOpenLeft(leftNode: AnyNode): boolean;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getMainChild(): AnyNode;
    getEmptyClone(): INonTerminal;
}
export declare class SupSubIndexNode extends NonTerminal implements ExpressionNode, HasOpenLeftChild, HasMainChild {
    readonly rightBoundary: PrivateTerminal;
    child: AnyNode;
    supIndex: AnyNode;
    subIndex: AnyNode;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getLeftChild(): AnyNode;
    isOpenLeft(leftNode: AnyNode): boolean;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getMainChild(): AnyNode;
    getEmptyClone(): INonTerminal;
}
export declare class PrimeNode extends NonTerminal implements ExpressionNode, HasOpenLeftChild, HasMainChild {
    readonly prime: PrivateTerminal;
    child: AnyNode;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getLeftChild(): AnyNode;
    isOpenLeft(leftNode: AnyNode): boolean;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getMainChild(): AnyNode;
    getEmptyClone(): INonTerminal;
}
export declare class LogNode extends NonTerminal implements HasOpenRightChild, ExpressionNode, HasMainChild {
    readonly log: PrivateTerminal;
    child: AnyNode;
    base: AnyNode;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getRightChild(): AnyNode;
    isOpenRight(rightNode: AnyNode): boolean;
    getRightPriority(rotateTarget?: AnyNode): number;
    getMainChild(): AnyNode;
    getEmptyClone(): INonTerminal;
}
export declare class LimNode extends NonTerminal implements HasOpenRightChild, ExpressionNode, HasMainChild {
    readonly lim: PrivateTerminal;
    readonly arrow: PrivateTerminal;
    child: AnyNode;
    var_approaches: AnyNode;
    const_limit: AnyNode;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getRightChild(): AnyNode;
    isOpenRight(rightNode: AnyNode): boolean;
    getRightPriority(rotateTarget?: AnyNode): number;
    getMainChild(): AnyNode;
    getEmptyClone(): INonTerminal;
}
export declare class DivideNode extends NonTerminal implements ExpressionNode, HasOpenLeftChild, PostInsertHook, HasMainChild {
    readonly sep: PrivateTerminal;
    numerator: AnyNode;
    denominator: AnyNode;
    private isOpen;
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getLeftChild(): AnyNode;
    isOpenLeft(leftNode: AnyNode): boolean;
    getLeftPriority(rotateTarget?: AnyNode): number;
    postInsert(): void;
    get closed(): boolean;
    close(): void;
    open(): void;
    getMainChild(): AnyNode;
    getEmptyClone(): INonTerminal;
}
export declare abstract class ProdOrSumNode extends NonTerminal implements HasOpenRightChild, HasMainChild {
    readonly main: PrivateTerminal;
    readonly eq: PrivateTerminal;
    child: AnyNode;
    to: AnyNode;
    from: AnyNode;
    var: AnyNode;
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    get children(): AnyNode[];
    getRightChild(): AnyNode;
    getRightPriority(rotateTarget?: AnyNode): number;
    isOpenRight(rightNode: AnyNode): boolean;
    abstract get isProduction(): boolean;
    get isSum(): boolean;
    getMainChild(): AnyNode;
}
export declare class ProdNode extends ProdOrSumNode {
    get isProduction(): boolean;
    getEmptyClone(): INonTerminal;
}
export declare class SumNode extends ProdOrSumNode {
    get isProduction(): boolean;
    getEmptyClone(): INonTerminal;
}
export declare class IntegralNode extends NonTerminal implements HasOpenRightChild, HasMainChild {
    readonly pt: PrivateTerminal;
    integrand: AnyNode;
    differential: AnyNode;
    upLimit: AnyNode;
    downLimit: AnyNode;
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    get children(): AnyNode[];
    getRightChild(): AnyNode;
    getRightPriority(rotateTarget?: AnyNode): number;
    isOpenRight(rightNode: AnyNode): boolean;
    getMainChild(): AnyNode;
    getEmptyClone(): INonTerminal;
}
export declare class ValueNode extends BasicTerminal implements AtomNode {
    readonly value: string;
    constructor(parent: INonTerminal, value?: string);
    asString(): string;
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
}
export declare enum NumSetLetters {
    CC = "C",
    NN = "N",
    QQ = "Q",
    RR = "R",
    ZZ = "Z"
}
export declare enum GreekLetters {
    alpha = "alpha",
    Alpha = "Alpha",
    beta = "beta",
    Beta = "Beta",
    gamma = "gamma",
    Gamma = "Gamma",
    delta = "delta",
    omega = "omega",
    Omega = "Omega",
    iota = "iota",
    Iota = "Iota",
    kappa = "kappa",
    Kappa = "Kappa",
    lambda = "lambda",
    Lambda = "Lambda",
    sigma = "sigma",
    epsi = "varepsilon",
    Epsi = "Varepsilon",
    upsi = "upsilon",
    Upsi = "Upsilon",
    zeta = "zeta",
    Zeta = "Zeta",
    theta = "vartheta",
    Theta = "Vartheta",
    tau = "tau",
    Tau = "Tau",
    phi = "varphi",
    Phi = "Varphi",
    rho = "varrho",
    Rho = "Varrho",
    mu = "mu",
    Mu = "Mu",
    nu = "nu",
    Nu = "Nu",
    xi = "xi",
    Xi = "Xi",
    chi = "chi",
    Chi = "Chi",
    psi = "psi",
    Psi = "Psi",
    eta = "eta",
    Eta = "Eta"
}
export declare class LettersUtils {
    static getByKey<T extends GreekLetters | NumSetLetters | Constants>(value: string, enumType: typeof GreekLetters | typeof NumSetLetters | typeof Constants): T;
    static getByValue<T extends GreekLetters | NumSetLetters | Constants>(name: string, enumType: typeof GreekLetters | typeof NumSetLetters | typeof Constants): T;
    static getKey<T extends GreekLetters | NumSetLetters | Constants>(value: T, enumType: typeof GreekLetters | typeof NumSetLetters | typeof Constants): string;
    static getSortValue(letter: GreekLetters): number;
    static getReadableNumset(ns: NumSetLetters): string;
    static getSymbolGreek(greek: GreekLetters): string;
    static getReadableGreek(greek: GreekLetters): string;
    static getReadableSymbolGreek(greek: GreekLetters): string;
    static getReadableConstant(constant: Constants): "e" | "infinity" | "pi" | "imaginary unit" | "complex infinity";
    static convertInternalToReadable<T extends GreekLetters | NumSetLetters | Constants>(internal: string, enumtype: typeof GreekLetters | typeof NumSetLetters | typeof Constants, useSymbols?: boolean): string;
}
export declare class NumsetVariableNode extends BasicTerminal {
    readonly name: NumSetLetters;
    constructor(parent: INonTerminal, name: NumSetLetters);
    asString(): string;
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
}
export declare class EmptysetVariableNode extends BasicTerminal {
    constructor(parent: INonTerminal);
    asString(): string;
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
}
export declare abstract class VariableNode extends BasicTerminal {
    abstract asString(): string;
    abstract getClone(): VariableNode;
}
export declare class GreekVariableNode extends VariableNode {
    readonly name: GreekLetters;
    constructor(parent: INonTerminal, name: GreekLetters);
    asString(): string;
    get greekLetterName(): GreekLetters;
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
    getClone(): GreekVariableNode;
}
export declare class LatinVariableNode extends VariableNode {
    readonly name: string;
    constructor(parent: INonTerminal, name: string);
    asString(): string;
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
    getClone(): LatinVariableNode;
}
export declare class PredicateNode extends NonTerminal implements HasOpenLeftChild, IPlainText {
    readonly br: PrivateTerminal;
    expr: AnyNode;
    string: AnyNode;
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    get children(): AnyNode[];
    getLeftChild(): AnyNode;
    getLeftPriority(rotateTarget?: AnyNode): number;
    isOpenLeft(leftNode: AnyNode): boolean;
    getTextNode(): AnyNode;
    getEmptyClone(): INonTerminal;
}
export interface IPlainText {
    getTextNode(): AnyNode;
}
export interface OperatorNameVisitor<T> {
    visitTrigName(node: TrigNameNode): T;
    visitDiff(node: DifferentialNode): T;
    visitLn(node: LnNode): T;
    visitInfSup(node: InfSupNameNode): T;
}
export declare abstract class OperatorNameNode extends BasicTerminal implements AtomNode {
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
    abstract acceptOperatorName<T>(visitor: OperatorNameVisitor<T>): T;
}
export declare class LnNode extends OperatorNameNode {
    asString(): string;
    acceptOperatorName<T>(visitor: OperatorNameVisitor<T>): T;
}
export declare class DifferentialNode extends OperatorNameNode {
    asString(): string;
    acceptOperatorName<T>(visitor: OperatorNameVisitor<T>): T;
}
export declare class TrigNameNode extends OperatorNameNode {
    readonly name: TrigName;
    constructor(parent: INonTerminal, name: TrigName);
    asString(): string;
    acceptOperatorName<T>(visitor: OperatorNameVisitor<T>): T;
}
export declare class InfSupNameNode extends OperatorNameNode {
    readonly isInf: boolean;
    constructor(parent: INonTerminal, isInf: boolean);
    asString(): string;
    acceptOperatorName<T>(visitor: OperatorNameVisitor<T>): T;
}
export declare enum Constants {
    zinfty = "zinf",
    imath = "imath",
    e = "e",
    pi = "pi",
    infinity = "inf"
}
export declare class ConstantNode extends BasicTerminal implements AtomNode {
    readonly const: Constants;
    constructor(parent: INonTerminal, constant: Constants);
    asString(): string;
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
}
export declare class FuncNode extends NonTerminal implements ExpressionNode, HasOpenLeftChild, HasOpenRightChild {
    readonly func: PrivateTerminal;
    operator: AnyNode;
    operand: AnyNode;
    constructor(parent: INonTerminal);
    get children(): AnyNode[];
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getLeftChild(): AnyNode;
    getRightChild(): AnyNode;
    isOpenLeft(leftNode: AnyNode): boolean;
    isOpenRight(rightNode: AnyNode): boolean;
    getLeftPriority(rotateTarget?: AnyNode): number;
    getRightPriority(rotateTarget?: AnyNode): number;
    getEmptyClone(): INonTerminal;
}
export interface SpaceContainer extends INonTerminal {
    createClone(rows: number, columns: number): SpaceContainer;
    getSpaceChild(rowIndex: number, columnIndex: number): AnyNode;
    getChildInsertPosition(node: AnyNode): Point | null;
    isRowAtomic?: boolean;
    readonly width: number;
    readonly height: number;
    readonly canChangeColumnsAmount: boolean;
    acceptSpaceContainer<T>(visitor: SpaceContainerVisitor<T>): T;
}
export interface SpaceContainerVisitor<T> {
    visitDeterminant(node: DeterminantNode): T;
    visitSystemOfEquations(node: SystemOfEquationsNode): T;
    visitPiecewiseFunction(node: PiecewiseFunctionNode): T;
}
export declare function isSpaceContainer(arg: any): arg is SpaceContainer;
export declare class DeterminantNode extends NonTerminal implements SpaceContainer {
    readonly main: PrivateTerminal;
    readonly elements: AnyNode[][];
    constructor(parent: INonTerminal, rows: number, columns: number);
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    acceptSpaceContainer<T>(visitor: SpaceContainerVisitor<T>): T;
    get children(): AnyNode[];
    getEmptyClone(): INonTerminal;
    createClone(rows: number, columns: number): SpaceContainer;
    getSpaceChild(rowIndex: number, columnIndex: number): AnyNode;
    getChildInsertPosition(node: AnyNode): Point | null;
    get height(): number;
    get width(): number;
    get canChangeColumnsAmount(): boolean;
}
export declare class SystemOfEquationsNode extends NonTerminal implements SpaceContainer {
    readonly main: PrivateTerminal;
    readonly elements: AnyNode[];
    constructor(parent: INonTerminal, rows: number);
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    acceptSpaceContainer<T>(visitor: SpaceContainerVisitor<T>): T;
    get children(): AnyNode[];
    getEmptyClone(): INonTerminal;
    createClone(rows: number, columns: number): SpaceContainer;
    getSpaceChild(rowIndex: number, columnIndex: number): AnyNode;
    getChildInsertPosition(node: AnyNode): Point | null;
    get height(): number;
    get width(): number;
    get canChangeColumnsAmount(): boolean;
}
export declare class PiecewiseFunctionNode extends NonTerminal implements SpaceContainer {
    readonly main: PrivateTerminal;
    readonly elements: AnyNode[];
    readonly predicates: AnyNode[];
    constructor(parent: INonTerminal, rows: number);
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    acceptSpaceContainer<T>(visitor: SpaceContainerVisitor<T>): T;
    get children(): AnyNode[];
    getEmptyClone(): INonTerminal;
    createClone(rows: number, columns: number): SpaceContainer;
    getSpaceChild(rowIndex: number, columnIndex: number): AnyNode;
    getChildInsertPosition(node: AnyNode): Point | null;
    get height(): number;
    get width(): number;
    get isRowAtomic(): boolean;
    get canChangeColumnsAmount(): boolean;
}
export declare class UndefinedNode extends BasicTerminal implements AtomNode {
    constructor(parent: INonTerminal);
    asString(): string;
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
}
