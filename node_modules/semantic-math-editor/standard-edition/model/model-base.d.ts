/**
 * @hidden
 * @packageDocumentation
 */
import { HasMainChild } from "./open-children";
export interface PostInsertHook {
    postInsert(): any;
}
export declare function hasPostInsertHook(arg: any): arg is PostInsertHook;
export declare class IdGen {
    private static maxId;
    private static _skip;
    static get currentId(): number;
    static skip(): void;
    static continue(): void;
    static nextId(): number;
    static reset(): void;
}
declare abstract class TreeNode implements AnyNode {
    nodeId: number;
    parent: INonTerminal;
    private nodeConstructorName;
    get nodeType(): string;
    constructor(parent: INonTerminal);
    abstract accept<T>(visitor: AnyNodeVisitor<T>): T;
    forEach<T>(func: (n: AnyNode) => T): T;
    with(callback: (node: this) => void): this;
}
export interface INonTerminal extends AnyNode {
    replaceChild(existingChild: AnyNode, newChild: AnyNode): boolean;
    children: AnyNode[];
    getEmptyClone(): INonTerminal;
    getByCode(code: PrivateTerminalCode): PrivateTerminal;
    forEachPrivateTerminal(f: (n: PrivateTerminal) => void): void;
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
}
export declare abstract class NonTerminal extends TreeNode implements INonTerminal {
    abstract get children(): AnyNode[];
    accept<T>(visitor: AnyNodeVisitor<T>): T;
    abstract acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    abstract getEmptyClone(): INonTerminal;
    getByCode(code: PrivateTerminalCode): PrivateTerminal;
    get privateTerminals(): PrivateTerminal[];
    forEachPrivateTerminal(f: (n: PrivateTerminal) => void): void;
    findNextBrother(leftBrother: AnyNode): AnyNode;
    toString(): string;
}
export declare abstract class Terminal extends TreeNode {
    abstract asString(): string;
    getPointer(left: boolean): TerminalPointer;
    toString(): string;
    accept<T>(visitor: AnyNodeVisitor<T>): T;
    abstract acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
    abstract get semanticNode(): AnyNode;
    abstract describeNode(): string;
}
export declare class TerminalPointer {
    readonly isLeft: boolean;
    readonly terminal: Terminal;
    constructor(terminal: Terminal, left: boolean);
    get nodeId(): number;
    toString(): string;
}
export interface TerminalVisitor<T> {
    visitRaw(node: RawNode): T;
    visitNothing?(node: NothingNode): T;
    visitPrivateTerminal?(node: PrivateTerminal): T;
}
export declare enum PrivateTerminalCode {
    default = "default",
    lim_lim = "lim_lim",
    lim_arrow = "lim_arrow",
    eq = "eq",
    cellLeftBoundary = "cellLeftBoundary",
    cellRightBoundary = "cellRightBoundary",
    border = "border"
}
export declare abstract class BasicTerminal extends Terminal {
    get semanticNode(): AnyNode;
    describeNode(): string;
}
export declare class PrivateTerminal extends BasicTerminal {
    readonly code: PrivateTerminalCode;
    readonly stringRepresentation: string;
    readonly hasStringRepresentation: boolean;
    constructor(parent: INonTerminal, code: PrivateTerminalCode, asString?: string);
    asString(): string;
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
    get semanticNode(): AnyNode;
    describeNode(): string;
}
export interface AnyNode {
    nodeId: number;
    parent: INonTerminal;
    nodeType: string;
    forEach<T>(func: (n: AnyNode) => T): T;
    accept<T>(visitor: AnyNodeVisitor<T>): T;
    with(callback: (node: this) => void): this;
}
export interface AnyNodeVisitor<T> {
    visitTerminal(node: Terminal): T;
    visitNonTerminal(node: NonTerminal): T;
}
export interface AtomNode extends AnyNode {
}
export interface ExpressionNode extends AnyNode {
}
export declare class RootNode extends NonTerminal {
    child: AnyNode;
    get children(): AnyNode[];
    get empty(): boolean;
    constructor();
    getEmptyClone(): INonTerminal;
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    getNodeById(id: number): AnyNode;
}
export declare class NothingNode extends BasicTerminal {
    constructor(parent: INonTerminal);
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
    asString(): string;
}
export interface CellVisitor<T> {
    visitPlain(node: PlainCellNode): T;
    visitNested(node: NestedCellNode): T;
}
export declare abstract class AbstractCellNode extends NonTerminal implements ExpressionNode, HasMainChild {
    child: AnyNode;
    acceptNonTerminal<T>(visitor: NonTerminalVisitor<T>): T;
    abstract acceptCell<T>(visitor: CellVisitor<T>): T;
    getMainChild(): AnyNode;
}
/**
 * Ячейка без вложенного визуального уровня с невидимыми символами по краям
 */
export declare class PlainCellNode extends AbstractCellNode {
    readonly leftBoundary: any;
    readonly rightBoundary: any;
    get children(): any[];
    acceptCell<T>(visitor: CellVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
/**
 * Ячейка с вложенным визуальным уровнем и видимыми скобками
 */
export declare class NestedCellNode extends AbstractCellNode {
    readonly par: any;
    get children(): any[];
    acceptCell<T>(visitor: CellVisitor<T>): T;
    getEmptyClone(): INonTerminal;
}
export declare class RawNode extends BasicTerminal {
    private _keyCode;
    constructor(parent: INonTerminal, key: number);
    get keyCode(): number;
    get key(): string;
    asString(): string;
    asLatexString(): string;
    acceptTerminal<T>(visitor: TerminalVisitor<T>): T;
}
export declare function guardSymbol(symbol: string, latexSpacingMode: boolean): string;
export declare function guardLatex(latex: string): string;
export declare function getRawLatexTextSymbol(guarded: string): any;
export interface NonTerminalVisitor<T> {
    visitRoot(node: RootNode): T;
    visitCell(node: AbstractCellNode): T;
}
export declare function isNothingNode(node: AnyNode): node is NothingNode;
export declare function isPrivateTerminal(node: AnyNode): node is PrivateTerminal;
export declare function isTerminal(node: AnyNode): node is Terminal;
export declare function isRoot(node: AnyNode): node is RootNode;
export {};
