/**
 * @hidden
 * @packageDocumentation
 */
import { AbstractCellNode, AnyNode, AnyNodeVisitor, NonTerminal, NonTerminalVisitor, NothingNode, RootNode, Terminal, TerminalPointer } from "../model/model-base";
import { AbstractBracketsNode, BinaryOperationNode, DeterminantNode, DivideNode, FuncNode, HiddenMultiplyNode, IntegralNode, LimNode, LogNode, MathRootNode, MinusNode, PiecewiseFunctionNode, PredicateNode, PrimeNode, ProdOrSumNode, SubIndexNode, SupIndexNode, SupSubIndexNode, SystemOfEquationsNode, TrigName, UnaryMinusNode } from "../model/model-math";
import { HasOpenLeftChild, HasOpenRightChild } from "../model/open-children";
import { VisualGraph } from "../structure/visual-levels";
import { SemanticContext } from "./semantic-context";
export declare class HintResult {
    affectedSubTree: AnyNode;
    readonly afterHintPointer: TerminalPointer;
    readonly omitRebuildVisualGraph: boolean;
    constructor(affectedSubTree: AnyNode, afterHintPointer: TerminalPointer, omitRebuildVisualGraph?: boolean);
}
export interface Hint {
    initialize(): void;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: AnyNode, visualGraph: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
}
export declare abstract class AbstractOperationPriorityHint implements Hint {
    useCanonicalTree: boolean;
    initialize(): void;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: AnyNode, visualGraph: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    private tryRotateLeft;
    private tryRotateRight;
    protected rotateLeftAvailable(leftPriority: number, rightPriority: number): boolean;
    protected rotateRightAvailable(leftPriority: number, rightPriority: number): boolean;
    protected abstract rotateLeftHandler(target: AnyNode, owner: HasOpenLeftChild, contender: HasOpenRightChild, log?: boolean): HintResult;
    protected abstract rotateRightHandler(target: AnyNode, owner: HasOpenRightChild, contender: HasOpenLeftChild, log?: boolean): HintResult;
}
export declare class OperationPriorityHint extends AbstractOperationPriorityHint {
    rotateLeftHandler(target: AnyNode, owner: HasOpenLeftChild, contender: HasOpenRightChild): HintResult;
    rotateRightHandler(target: AnyNode, owner: HasOpenRightChild, contender: HasOpenLeftChild, log?: boolean): HintResult;
    toString(): string;
}
interface HiddenMultiplyRemover {
    tryReplace(node: HiddenMultiplyNode, pointerFromLastHint?: TerminalPointer): HintResult;
}
export declare class HiddenMultiplyRemoveHint implements Hint {
    removers: HiddenMultiplyRemover[];
    constructor(removers?: HiddenMultiplyRemover[]);
    initialize(): void;
    private static createDefaultRemovers;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: AnyNode, vg: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    toString(): string;
}
export declare class BinaryMinusToUnaryHint implements Hint {
    initialize(): void;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: MinusNode, vg: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    toString(): string;
}
export declare class TerminalSequence {
    sequence: string;
    readonly nodeAtIndex: Terminal[];
    add(s: string, node: Terminal): TerminalSequence;
    addFirst(s: string, node: Terminal): TerminalSequence;
    validMatch(index: number, len: number): boolean;
    isEmpty(): boolean;
}
export declare enum ReplacementAdvicePriority {
    spaceModify = 0,
    exactMatchReplacement = 1,
    finalizer = 2,
    variableInsert = 3,
    functionVariable = 4,
    bracketsConvert = 5,
    function = 6,
    equality = 7,
    symbolicOperation = 8,
    logicalOperation = 9,
    setOperation = 10,
    include = 11,
    trigFunction = 12,
    brackets = 13,
    set = 14,
    constant = 15,
    numset = 16,
    variable = 17
}
export declare class Replacement {
    readonly sequence: string;
    readonly replacementCreator: (terminals: Terminal[]) => (HintResult);
    readonly isAllowed: (terminals: Terminal[]) => boolean;
    readonly replacementPriority: ReplacementAdvicePriority;
    readonly prohibitElementReplacement: boolean;
    readonly isContextDependent: boolean;
    constructor(sequence: string, replacementCreator: (terminals: Terminal[]) => HintResult, assignedPriority: ReplacementAdvicePriority, isAllowed?: (nodes: AnyNode[]) => boolean, prohibitElementReplacement?: boolean, isContextDependent?: boolean);
    replaceNodes(nodesToBeReplaced: AnyNode[], vg: VisualGraph, terminalsToBeReplaced?: Terminal[]): HintResult;
}
export declare class CharSequenceReplacementHint implements Hint {
    replacements: Replacement[];
    constructor(replacements?: Replacement[]);
    initialize(): void;
    private static createDefaultReplacements;
    static getTrigHintResultWithCheckNeedBrackets(terminals: Terminal[], trigName: TrigName): HintResult;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: AnyNode, vg: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    toString(): string;
    private static findTerminalSequnces;
    private static findMatchInSequences;
}
export declare class ValueCompositionHint implements Hint {
    initialize(): void;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: AnyNode, visualGraph: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    private static findValueSequences;
    private static compositeValue;
}
export declare abstract class AbstractSupSubRecoverHint implements Hint {
    initialize(): void;
    isChildNeedsToBeRecovered(node: SupIndexNode | SubIndexNode | SupSubIndexNode | PrimeNode): boolean;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: SupIndexNode | SubIndexNode | SupSubIndexNode | PrimeNode, vg: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    abstract apply(node: SupIndexNode | SubIndexNode | SupSubIndexNode | PrimeNode): HintResult;
}
export declare class SupSubRecoverHint extends AbstractSupSubRecoverHint {
    apply(node: SupIndexNode | SubIndexNode | SupSubIndexNode | PrimeNode): HintResult;
    toString(): string;
}
export declare class FunctionCompositionHint implements Hint {
    initialize(): void;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: AnyNode, visualGraph: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    toString(): string;
}
export declare class FunctionDecompositionHint implements Hint {
    initialize(): void;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: FuncNode, visualGraph: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    toString(): string;
}
export declare class OpenLeftInFuncOperandHint implements Hint {
    initialize(): void;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    getOperandOpenLeftNothing(operand: AnyNode, vg: VisualGraph): NothingNode;
    tryApply(node: FuncNode, vg: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    toString(): string;
}
export declare class SupSubCompositionHint implements Hint {
    initialize(): void;
    getSupSubContent(node: SupIndexNode | SubIndexNode): {
        child: AnyNode;
        supIndex: AnyNode;
        subIndex: AnyNode;
        innerNode: SupIndexNode | SubIndexNode;
    };
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: SupIndexNode | SubIndexNode, vg: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    toString(): string;
}
export declare class DifferentialVariableRecognition implements Hint {
    private changeToDifferential;
    private replacementCallback;
    constructor(replacementCallback?: (source: Terminal, replacement: Terminal) => void);
    initialize(): void;
    isApplicable(node: AnyNode, vg: VisualGraph): boolean;
    tryApply(node: AnyNode, visualGraph: VisualGraph, context: SemanticContext, pointerFromLastHint?: TerminalPointer, log?: boolean): HintResult;
    private isValidDifferentialAndLeibnizDerivative;
    private isValidDifferential;
    private isValidLeibnizDerivative;
}
export declare class NextTransformationNonTerminalVisitor implements AnyNodeVisitor<boolean>, NonTerminalVisitor<boolean> {
    readonly node: Terminal;
    constructor(node: Terminal);
    visitNonTerminal(node: NonTerminal): boolean;
    visitTerminal(node: Terminal): boolean;
    visitAbstractBrackets(node: AbstractBracketsNode): boolean;
    visitBinaryOperation(node: BinaryOperationNode): boolean;
    visitCell(node: AbstractCellNode): boolean;
    visitDeterminant(node: DeterminantNode): boolean;
    visitDivide(node: DivideNode): boolean;
    visitFunction(node: FuncNode): boolean;
    visitInt(node: IntegralNode): boolean;
    visitLim(node: LimNode): boolean;
    visitLog(node: LogNode): boolean;
    visitMathRoot(node: MathRootNode): boolean;
    visitPiecewiseFunction(node: PiecewiseFunctionNode): boolean;
    visitPredicate(node: PredicateNode): boolean;
    visitPrime(node: PrimeNode): boolean;
    visitProdOrSum(node: ProdOrSumNode): boolean;
    visitRoot(node: RootNode): boolean;
    visitSub(node: SubIndexNode): boolean;
    visitSup(node: SupIndexNode): boolean;
    visitSupSub(node: SupSubIndexNode): boolean;
    visitSystemOfEquations(node: SystemOfEquationsNode): boolean;
    visitUnaryMinus(node: UnaryMinusNode): boolean;
}
export {};
