/**
 * @hidden
 * @packageDocumentation
 */
import { Terminal } from "../model/model-base";
import { SelectionEditor } from "../editor/selection-editor";
import { RenderedTree } from "../editor/editor-support";
import { Point } from "../model/utils";
import { HorizontalDirection, VerticalDirection } from "../engine/utils";
export interface MouseSelectionConfig {
    frame: number;
    minDistance: number;
}
export declare enum CursorSide {
    left = "left",
    right = "right"
}
export interface CursorNode {
    nodeId: number;
    side: CursorSide;
}
export interface MouseSelectionCallbacks {
    onSelection(): void;
    onPlaceCursor(): void;
}
export declare class MouseSelection {
    disabled: boolean;
    private readonly editor;
    private readonly element;
    private readonly callbacks;
    private readonly getRenderedTree;
    private started;
    private selectionStarted;
    private startPoint;
    private startNode;
    private startOppositeNode;
    private startPointer;
    private stopNode;
    private stopHorizontalDirection;
    private stopVerticalDirection;
    readonly destroy: () => void;
    private lastTouch;
    constructor(editor: SelectionEditor, element: HTMLElement, config: MouseSelectionConfig, isLocked: () => boolean, getRenderedTree: () => RenderedTree, callbacks: MouseSelectionCallbacks);
    getX(event: MouseEvent | TouchEvent): number;
    getY(event: MouseEvent | TouchEvent): number;
    getPoint(event: MouseEvent | TouchEvent): Point;
    private onStart;
    private onMove;
    private getBaseLevelTerminal;
    private onEnd;
    finishSelection(): void;
    selectionChanged(terminal: Terminal, horizontalDirection: HorizontalDirection, verticalDirection: VerticalDirection): boolean;
    cleanup(): void;
    placeCursor({ nodeId, side }: CursorNode): void;
    selectInRectangle(startPoint: Point, endPoint: Point, config: MouseSelectionConfig): boolean;
    getSelectionDirection(startPoint: Point, endPoint: Point, startNode: CursorNode, endNode: CursorNode): {
        horizontalDirection: HorizontalDirection;
        verticalDirection: VerticalDirection;
    };
    /**
     * @description Supposing every element to be a rectangle, returns the element with minimal distance.
     */
    getNearestNode(point: Point): CursorNode;
    /**
     * @description Supposing every element to be a rectangle, compute minimal distance to given point among all
     * left and right borders of all elements and return the element with minimal distance.
     */
    getNearestPointer(point: Point): CursorNode;
}
