/**
 * @hidden
 * @packageDocumentation
 */
import { KatexTree } from "./tree/AST";
import { KatexNodeVisitor } from "./tree/visitors";
import { Operation } from "./tree/op";
import { Text } from "./tree/text";
import { AbstractSymbol } from "./tree/symbols";
import { ArrayEnvironment, CasesEnvironment, MatrixEnvironment } from "./tree/environment";
import { Fraction } from "./tree/genfrac";
import { Placeholder } from "./tree/placeholder";
import { Phantom } from "./tree/phantom";
import { Accent } from "./tree/accent";
import { AccentUnder } from "./tree/accentunder";
import { ExtensibleArrow } from "./tree/arrow";
import { Color } from "./tree/color";
import { Delimsizing, LeftRight, Middle } from "./tree/delimsizing";
import { Box } from "./tree/enclose";
import { Font } from "./tree/font";
import { MathClass } from "./tree/mclass";
import { Ordgroup } from "./tree/ordgroup";
import { HorizontalBrace } from "./tree/horizBrace";
import { Lap } from "./tree/lap";
import { Kern } from "./tree/kern";
import { Overline } from "./tree/overline";
import { Supsub } from "./tree/supsub";
import { Underline } from "./tree/underline";
import { OperatorName } from "./tree/operatorname";
import { RaiseBox } from "./tree/raisebox";
import { Rule } from "./tree/rule";
import { Sizing } from "./tree/sizing";
import { Smash } from "./tree/smash";
import { Sqrt } from "./tree/sqrt";
import { Styling } from "./tree/styling";
import { Href } from "./tree/href";
import { VisualSymbol } from "../../structure/visual-levels";
export declare class MetricsVisitor implements KatexNodeVisitor<ClientRect> {
    private readonly rootElement;
    private readonly katexNodeElementCache;
    constructor(element: Element, katexNodeElementCache: Map<string, Element>);
    private rect;
    private childRect;
    private enclosingWithChildRect;
    visitRoot(tree: KatexTree): ClientRect;
    visitOperation(node: Operation): ClientRect;
    visitText(node: Text): ClientRect;
    visitColor(node: Color): ClientRect;
    visitRule(node: Rule): ClientRect;
    visitMathClass(node: MathClass): ClientRect;
    visitLap(node: Lap): ClientRect;
    visitSmash(node: Smash): ClientRect;
    visitFont(node: Font): ClientRect;
    visitEnclose(node: Box): ClientRect;
    visitRaiseBox(node: RaiseBox): ClientRect;
    visitStyling(node: Styling): ClientRect;
    visitSizing(node: Sizing): ClientRect;
    visitKern(node: Kern): ClientRect;
    visitSqrt(node: Sqrt): ClientRect;
    visitAccent(node: Accent): ClientRect;
    visitHorizontalBrace(node: HorizontalBrace): ClientRect;
    visitAccentUnder(node: AccentUnder): ClientRect;
    visitExtensibleArrow(node: ExtensibleArrow): ClientRect;
    visitSupsub(node: Supsub): ClientRect;
    visitLeftRight(node: LeftRight): ClientRect;
    visitOrdgroup(node: Ordgroup): ClientRect;
    visitOverline(node: Overline): ClientRect;
    visitUnderline(node: Underline): ClientRect;
    visitAbstractSymbol(node: AbstractSymbol): ClientRect;
    visitArrayEnvironment(node: ArrayEnvironment): ClientRect;
    visitMatrixEnvironment(node: MatrixEnvironment): ClientRect;
    visitCasesEnvironment(node: CasesEnvironment): ClientRect;
    visitFraction(node: Fraction): ClientRect;
    visitPlaceholder(node: Placeholder): ClientRect;
    visitPhantom(node: Phantom): ClientRect;
    visitDelimsizing(node: Delimsizing): ClientRect;
    visitOperatorName(node: OperatorName): ClientRect;
    visitHref(node: Href): ClientRect;
    /**
     *  Так как на элементе соответствующему Middle нету отличительных аттрибутов, мы ищем его в родителе между
     *  курсорами оборачивающими его
     */
    visitMiddle(node: Middle): ClientRect;
    private getOpenRect;
    private getCloseRect;
    /**
     * @param span
     * Берет ширину указанного span элемента и высоту внутреннего span для которого браузер её корректно определяет.
     */
    private getOpenMiddleCloseRect;
    /**
     * @param span
     * Ищем внутри span-элемента элемент, для которого браузер корректно определяет высоту.
     */
    private getActualHeightSpanRect;
    private selectNodeElement;
}
export declare function enclosingRect(...rects: ClientRect[]): ClientRect;
export declare class MetricsRows {
    rows: MetricsRow[];
    constructor(visibleBaseLevelSymbols: {
        symbol: VisualSymbol;
        metric: ClientRect;
    }[]);
    addMetrics(metrics: ClientRect[], baseLevelId: number, id: number): void;
    getRowNumberByBaseLevelSymbolId(id: number): number;
    get nonEmptyRows(): MetricsRow[];
}
export declare class MetricsRow {
    ids: number[];
    rects: ClientRect[];
    baseLevelIds: number[];
    right: number;
    bottom: number;
    push(rects: ClientRect[], id: number): void;
    get isEmpty(): boolean;
}
