/**
 * @hidden
 * @packageDocumentation
 */
import { AbstractCellNode, AnyNode, AnyNodeVisitor, NonTerminal, NonTerminalVisitor, NothingNode, RawNode, RootNode, Terminal, TerminalVisitor } from "../model/model-base";
import { AbsNode, AbstractBracketsNode, AndNode, ApproxEqualsNode, BinaryOperationNode, BinaryOperationNodeVisitor, BracketsNodeVisitor, ClosedIntervalNode, CommaNode, ConstantNode, DeterminantNode, DifferentialNode, DivideNode, EmptysetVariableNode, EqualsNode, FuncNode, GreaterOrEqualsNode, GreaterThanNode, GreekVariableNode, IncludeSetNode, InfSupNameNode, IntegralNode, IntersectionSetNode, LatinVariableNode, LeftClosedIntervalNode, LessOrEqualsNode, LessThanNode, LimNode, LnNode, LogNode, MathRootNode, MinMaxNode, MinusNode, MultiplyNode, NotEqualsNode, NumsetVariableNode, OpenBracketsNode, OperatorNameNode, OperatorNameVisitor, OrNode, PiecewiseFunctionNode, PlusNode, PredicateNode, PrimeNode, ProdOrSumNode, RightClosedIntervalNode, SetNode, SubIndexNode, SupIndexNode, SupSubIndexNode, SystemOfEquationsNode, TrigNameNode, UnaryMinusNode, UndefinedNode, UnionSetNode, ValueNode, VerticalBarNode } from "../model/model-math";
import { RNG } from "../engine/rng";
import { Hint, Replacement } from "../engine/hints";
import { HintManager } from "../engine/hint-manager";
import { SelectionEditorImpl } from "../editor/selection-editor";
declare class TypistInserter {
    readonly insert: (ed: SelectionEditorImpl) => void;
    readonly terminal: Terminal;
    readonly forceWithoutRetype: boolean;
    leftStep: (ed: SelectionEditorImpl) => void;
    rightStep: (ed: SelectionEditorImpl) => void;
    deleteStep: (ed: SelectionEditorImpl, withBs: boolean, atLeft: boolean) => void;
    constructor(insert: (ed: SelectionEditorImpl) => void, terminal: Terminal, forceWithoutRetype?: boolean);
    goLeft(ed: SelectionEditorImpl): void;
    goRight(ed: SelectionEditorImpl): void;
    deleteAtLeft(ed: SelectionEditorImpl, withBs: boolean, log?: boolean): void;
    deleteAtRight(ed: SelectionEditorImpl, withBs: boolean, log?: boolean, force?: boolean): void;
    toString(): string;
}
declare class NodeParts {
    readonly sequences: {
        [baseTerminalId: number]: {
            terminals: {
                terminal: Terminal;
                index: number[];
            }[];
            name: string;
        };
    };
    remove(terminal: Terminal): void;
    /**
     * Добавляет в последовательность разрешенных терминалов новый терминал.
     * При необходимости создает новую последовательнсть разрешенных терминалов.
     * @param baseTerminal базовый терминал литерала
     * @param name текстовое представление литерала
     * @param terminal добавляемый терминал
     * @param index массив индексов, которые занимает добавляемый терминал в текстовом представлении литерала
     */
    add(baseTerminal: Terminal, name: string, terminal: Terminal, index: number[]): void;
    /**
     * Проверяет, разрешено ли объеденение терминалов в литерал
     * @param terminals терминалы для объединения
     * @param suitableForFurtherReplacement возможно ли дальнейшее объединение терминалов с использованием получившегося.
     * Другими словами, будет ли текстовое представление нового терминала соответствовать текстовому представлению терминалов,
     * из которых он объеденился.
     */
    isAllowed(terminals: Terminal[], suitableForFurtherReplacement: boolean): boolean;
    addByTerminal(oldTerminal: Terminal, terminal: Terminal): void;
    /**
     * Добавляет в существующую последовательность разрешенных терминалов новый терминал.
     * Последовательность разрешенных терминалов выбирается на основе существующих терминалов.
     * Ищутся все последовательности разрешенных терминалов, содержащие указанные и выбирается первая.
     * @param oldTerminals сущесвующие терминалы, используемые для объединения в новый терминал
     * @param terminal добавляемый терминал
     */
    addByTerminals(oldTerminals: Terminal[], terminal: Terminal): void;
    /**
     * Проверяет, что все терминалы содержатся в последовательности разрешенных терминалах
     * @param allowedTerminals последовательность разрешенных терминалов
     * @param terminals терминалы, которые должны содержатся в последовательности разрешенных терминалов
     */
    private matches;
    /**
     * Фильтрует последовательность разрешенных терминалов, возвращая только те, которые соответствуют указанным терминалам
     * @param allowedTerminals последовательность разрешенных терминалов
     * @param terminals терминалы, по которым нужно найти разрешенные терминалы
     */
    private filterAllowedTerminals;
    createDefaultReplacements(): Replacement[];
    createDefaultHints(): Hint[];
}
declare class Hintable {
    readonly start: number;
    readonly end: number;
    private _typedSymbols;
    constructor(start: number, end: number);
    matches(index: number): boolean;
    get typed(): boolean;
    empty(): boolean;
    get length(): number;
    symbolTyped(): void;
    symbolRemoved(): void;
    completelyRemoved(): void;
    completelyRestored(): void;
}
/**
 * Класс предназначен для тестирования редактора.
 *
 * Цель этого класса - набирать выражения из семантического дерева в новом редакторе в случайном порядке.
 *
 * Класс умеет набирать литералы (такие как 'sin') тоже в случайном порядке. Причем в глобальном контексте
 * (типа печатаю 'i' от синуса, потом кучу всего, к синусу не относящегося, потом возвращаю курсор и печатаю 's', опять что-то левое, наконец возвращаю и печатаю 'n')
 *
 * По умолчанию класс набирает каждый элемент дважды: набирает, тут же стирает и набирает снова. Этот режим хорош для тестов.
 * Его можно выключить, передав параметр в конструктор.
 *
 * Этот класс умеет создавать собственный HintManager, который запрещает выполнение хинтов-автозамен в непредназначенных для этого ситуациях
 * Автозамена будет выполняться только на тех буковках, которые изначально состаляли литерал.
 * Без этого, возникало множество проблем вроде: "sixn" - это произведение 4х переменных
 * Но при определенном порядке ввода это окажется произведением x и синуса
 */
export declare class RandomTypist implements AnyNodeVisitor<void>, NonTerminalVisitor<void>, TerminalVisitor<void>, BinaryOperationNodeVisitor<void>, OperatorNameVisitor<void>, BracketsNodeVisitor<void> {
    protected readonly inserters: TypistInserter[];
    protected _log: boolean;
    readonly nodeParts: NodeParts;
    private _rng;
    private _deleteAndRetype;
    constructor(rng: RNG, log?: boolean, deleteAndRetype?: boolean, ntp?: NodeParts);
    private insert;
    run(editor: SelectionEditorImpl): void;
    private createSubTypist;
    private randomizeOrder;
    private swap;
    private nextBoolean;
    private addRandomLiteral;
    private deleteByInserters;
    private deleteInChildLevelByInserters;
    private goLeftByInserters;
    private goRightByInserters;
    visitTerminal(node: Terminal): void;
    visitNonTerminal(node: NonTerminal): void;
    visitFunction(node: FuncNode): void;
    visitLim(node: LimNode): void;
    visitProdOrSum(node: ProdOrSumNode): void;
    visitLog(node: LogNode): void;
    visitSup(node: SupIndexNode): void;
    visitSub(node: SubIndexNode): void;
    visitSupSub(node: SupSubIndexNode): void;
    handleSupSub(node: AnyNode, child: AnyNode, supIndex: AnyNode, subIndex: AnyNode, terminal: Terminal, handleInsertOperationCallback: (ed: SelectionEditorImpl) => void): void;
    visitValue(node: ValueNode): void;
    visitMathRoot(node: MathRootNode): void;
    visitCell(node: AbstractCellNode): void;
    visitAbstractBrackets(node: AbstractBracketsNode): void;
    visitAbs(node: AbsNode): void;
    visitMinMax(node: MinMaxNode): void;
    visitClosed(node: ClosedIntervalNode): void;
    visitLeftClosed(node: LeftClosedIntervalNode): void;
    visitOpen(node: OpenBracketsNode): void;
    visitRightClosed(node: RightClosedIntervalNode): void;
    visitSet(node: SetNode): void;
    private handleSurroundingOperationWithNode;
    private handleSurroundingOperationByTyping;
    visitNothing(node: NothingNode): void;
    private handleSurroundingOperation;
    createHintManager(): HintManager;
    protected log(s: string): void;
    protected push(f: (ed: SelectionEditorImpl) => void, terminal: Terminal, forceWithoutRetype?: boolean): TypistInserter;
    visitRaw(node: RawNode): void;
    visitBinaryOperation(node: BinaryOperationNode): void;
    visitPredicate(node: PredicateNode): void;
    visitAnd(node: AndNode): void;
    visitOr(node: OrNode): void;
    visitIntersection(node: IntersectionSetNode): void;
    visitUnion(node: UnionSetNode): void;
    private handleBinaryOperationWithNode;
    private handleBinaryOperationAsRandomLiteral;
    visitInclude(node: IncludeSetNode): void;
    visitApproxEquals(node: ApproxEqualsNode): void;
    visitComma(node: CommaNode): void;
    visitEquals(node: EqualsNode): void;
    visitGreaterOrEquals(node: GreaterOrEqualsNode): void;
    visitGreaterThan(node: GreaterThanNode): void;
    visitLessOrEquals(node: LessOrEqualsNode): void;
    visitLessThan(node: LessThanNode): void;
    visitMinus(node: MinusNode): void;
    visitMultiply(node: MultiplyNode): void;
    visitNotEquals(node: NotEqualsNode): void;
    visitPlus(node: PlusNode): void;
    visitVerticalBar(node: VerticalBarNode): void;
    visitDivide(node: DivideNode): void;
    visitUnaryMinus(node: UnaryMinusNode): void;
    visitLatin(node: LatinVariableNode): void;
    visitGreek(node: GreekVariableNode): void;
    visitNumset(node: NumsetVariableNode): void;
    visitEmptyset(node: EmptysetVariableNode): void;
    private handleVariable;
    visitPrime(node: PrimeNode): void;
    visitOperatorName(node: OperatorNameNode): void;
    visitTrigName(node: TrigNameNode): void;
    generateHintable(name: string): Hintable[];
    visitLn(node: LnNode): void;
    private handleWithNode;
    visitInfSup(node: InfSupNameNode): void;
    visitConstant(node: ConstantNode): void;
    visitUndefined(node: UndefinedNode): void;
    visitRoot(node: RootNode): void;
    visitDiff(node: DifferentialNode): void;
    visitInt(node: IntegralNode): void;
    visitDeterminant(node: DeterminantNode): void;
    visitSystemOfEquations(node: SystemOfEquationsNode): void;
    visitPiecewiseFunction(node: PiecewiseFunctionNode): void;
}
export {};
