/**
 * @hidden
 * @packageDocumentation
 */
import { SelectionEditor, SelectionEditorImpl, SelEditorState } from "./selection-editor";
import { AbstractCellNode, AnyNode, RootNode, Terminal, TerminalPointer } from "../model/model-base";
import { LevelLocation, VisualGraph } from "../structure/visual-levels";
import { InsertOperation } from "../model/insert-operation";
import { NavDirection, Stateful } from "./editor";
import { ConfirmRequiredOperation } from "../engine/internal-engine";
import { SemanticContext } from "../engine/semantic-context";
import { Selection } from "../engine/selection/selection";
import { HorizontalDirection, VerticalDirection } from "../engine/utils";
import { CursorPosition } from "../model/cursor-position";
export declare enum CellType {
    plain = "plain",
    nested = "nested",
    auto = "auto"
}
export declare namespace CellType {
    function parse(str: string): CellType;
}
export declare class EditableCellState {
    borderVisibility: boolean;
    type: CellType;
    constructor(borderVisibility: boolean, type?: CellType);
}
export interface EditableGroupRoot {
    readonly cell: AbstractCellNode;
    readonly state: EditableCellState;
    readonly root: AnyNode;
}
export interface MultiCellEditor extends SelectionEditor {
    makeEditable(node: AnyNode, borderVisible: boolean, avoidParenthesesWrap: boolean, skipFireHints: boolean): void;
    getEditableGroupRoots(): EditableGroupRoot[];
    clone(): MultiCellEditor;
}
export declare class MultiCellEditorImpl implements MultiCellEditor, Stateful<MultiCellEditorState> {
    private readonly editor;
    private cells;
    constructor(editor: SelectionEditorImpl);
    rebuildVisualGraph(): void;
    makeEditable(node: AnyNode, borderVisible: boolean, avoidParenthesesWrap: boolean, skipFireHints: boolean): void;
    setRoot(root: RootNode): void;
    get semanticContext(): SemanticContext;
    set semanticContext(val: SemanticContext);
    clone(): MultiCellEditorImpl;
    private isReadOnly;
    private isEditable;
    getEditableGroupRoots(): EditableGroupRoot[];
    private cloneToNewEditor;
    private updateParenthesesWrap;
    private addOrRemoveParenthesesWrap;
    private emptyCell;
    handleInsertOperation(insertOperation: InsertOperation, log?: boolean, beforeHintPointerAcceptor?: (pointer: TerminalPointer) => void): boolean;
    handleDeleteOperation(direction: HorizontalDirection, askToForce: boolean, log?: boolean, beforeHintPointerAcceptor?: (pointer: TerminalPointer) => void, statusCallback?: (succes: boolean) => void): ConfirmRequiredOperation;
    private deleteFromCellWithSelection;
    private deleteFromCellWithoutSelection;
    cut(): string;
    set onUpdate(value: () => void);
    paste(text: string, log?: boolean): void;
    pasteInsertOperation(insertOperation: InsertOperation, log?: boolean): void;
    get visualGraph(): VisualGraph;
    dropSelection(putCursorAtSelectionEnd: boolean): boolean;
    selectionStep(nav: NavDirection): boolean;
    createSelection(startPointer: TerminalPointer, stop: Terminal, horizontalDirection: HorizontalDirection, verticalDirection: VerticalDirection): boolean;
    moveSelectionHorizontalBoundary(leftBoundary: boolean, direction: HorizontalDirection): boolean;
    moveSelectionVerticalBoundary(topBoundary: boolean, direction: VerticalDirection): boolean;
    get selection(): Selection;
    copyTree(): AnyNode;
    copy(): string;
    navigate(where: NavDirection, skipBackToParent?: boolean): boolean;
    moveToLevelEdge(direction: HorizontalDirection, skipBackToParent?: boolean): boolean;
    placeCursorAtPointer(pointer: TerminalPointer, log?: boolean): void;
    get cursorPosition(): CursorPosition;
    get cursorAtBaseLevel(): boolean;
    setCursorPosition(cursorPosition: CursorPosition): void;
    getRoot(): RootNode;
    setToBaseVisualLevel(): void;
    skipSymbol(skipBackToParent: boolean): boolean;
    backToVisualParent(placeCursorAtLeft?: boolean): boolean;
    moveToVisualChild(levelLocation: LevelLocation, preferRight?: boolean): boolean;
    restoreState(state: MultiCellEditorState): void;
    saveState(): MultiCellEditorState;
    private index;
    fireHints(log?: boolean): void;
    replaceChild(existingChild: AnyNode, newChild: AnyNode): boolean;
    getBoundaryTerminal(left: boolean, onlyVisible?: boolean): Terminal;
}
export interface MultiCellEditorState {
    inner: SelEditorState;
    cellStates: {
        cellIndex: number;
        borderVisibility: boolean;
        type: string;
    }[];
}
